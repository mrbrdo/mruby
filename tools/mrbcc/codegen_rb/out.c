mrb_value met_eebe105d879ab921e0636da403fe1ffd(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_EEBE105D879AB921E0636DA403FE1FFD_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TypeError"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_EEBE105D879AB921E0636DA403FE1FFD_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "superclass"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_EEBE105D879AB921E0636DA403FE1FFD_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_EEBE105D879AB921E0636DA403FE1FFD_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_EEBE105D879AB921E0636DA403FE1FFD_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2b7755a6968750d16badd71878050b63(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_2B7755A6968750D16BADD71878050B63_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TypeError"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_2B7755A6968750D16BADD71878050B63_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_2B7755A6968750D16BADD71878050B63_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Class"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_2B7755A6968750D16BADD71878050B63_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_2B7755A6968750D16BADD71878050B63_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_536177b75d41c9ae94c669a75074b60d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADT", 1, 0, 0]
  L_MET_536177B75D41C9AE94C669A75074B60D_0:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_536177B75D41C9AE94C669A75074B60D_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_536177B75D41C9AE94C669A75074B60D_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "|"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 3]
  L_MET_536177B75D41C9AE94C669A75074B60D_3:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_536177B75D41C9AE94C669A75074B60D_7;
      }
      NEXT;
    }

  // ["OP_LOADT", 1, 0, 0]
  L_MET_536177B75D41C9AE94C669A75074B60D_4:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADF", 2, 0, 0]
  L_MET_536177B75D41C9AE94C669A75074B60D_5:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_536177B75D41C9AE94C669A75074B60D_6:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "|"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_536177B75D41C9AE94C669A75074B60D_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b50016d86bf1b55837f26841d8b62feb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADT", 1, 0, 0]
  L_MET_B50016D86BF1B55837F26841D8B62FEB_0:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 0]
  L_MET_B50016D86BF1B55837F26841D8B62FEB_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 0]
  L_MET_B50016D86BF1B55837F26841D8B62FEB_2:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "true");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 1, 1]
  L_MET_B50016D86BF1B55837F26841D8B62FEB_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B50016D86BF1B55837F26841D8B62FEB_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_25abf1625d3a6304f62c8bea86ea70f3(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADT", 1, 0, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_0:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "^"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 1, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 3]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_8;
      }
      NEXT;
    }

  // ["OP_LOADT", 1, 0, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_5:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADF", 2, 0, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_6:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_7:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "^"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_25ABF1625D3A6304F62C8BEA86EA70F3_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_9562233351605954161511b536e74f3d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADT", 1, 0, 0]
  L_MET_9562233351605954161511B536E74F3D_0:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_9562233351605954161511B536E74F3D_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_9562233351605954161511B536E74F3D_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "&"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 4]
  L_MET_9562233351605954161511B536E74F3D_3:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_9562233351605954161511B536E74F3D_8;
      }
      NEXT;
    }

  // ["OP_LOADT", 1, 0, 0]
  L_MET_9562233351605954161511B536E74F3D_4:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_LOADF", 2, 0, 0]
  L_MET_9562233351605954161511B536E74F3D_5:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_9562233351605954161511B536E74F3D_6:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "&"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 1, 0]
  L_MET_9562233351605954161511B536E74F3D_7:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_9562233351605954161511B536E74F3D_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_57dd23c795111a9eca73ab04f45e4b59(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADT", 0, 0, 0]
  L_MET_57DD23C795111A9ECA73AB04F45E4B59_0:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[0]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_57DD23C795111A9ECA73AB04F45E4B59_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b3acd40bf2d93567c0ae038237275750(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_B3ACD40BF2D93567C0AE038237275750_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TrueClass"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_B3ACD40BF2D93567C0AE038237275750_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "superclass"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_B3ACD40BF2D93567C0AE038237275750_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_B3ACD40BF2D93567C0AE038237275750_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B3ACD40BF2D93567C0AE038237275750_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5f1cbed8106e4bda94be896a69621890(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_5F1CBED8106E4BDA94BE896A69621890_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TrueClass"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_5F1CBED8106E4BDA94BE896A69621890_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_5F1CBED8106E4BDA94BE896A69621890_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Class"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_5F1CBED8106E4BDA94BE896A69621890_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_5F1CBED8106E4BDA94BE896A69621890_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b79e959d54168569fb5b023e300e2341(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_B79E959D54168569FB5B023E300E2341_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_B79E959D54168569FB5B023E300E2341_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_B79E959D54168569FB5B023E300E2341_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_B79E959D54168569FB5B023E300E2341_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_B79E959D54168569FB5B023E300E2341_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "inspect"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_B79E959D54168569FB5B023E300E2341_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_B79E959D54168569FB5B023E300E2341_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B79E959D54168569FB5B023E300E2341_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_10a336857edd72daae9bb134f28e571b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_10A336857EDD72DAAE9BB134F28E571B_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a88747527a10e6148f1dee65b545da4b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "zone"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "UTC");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_A88747527A10E6148F1DEE65B545DA4B_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b657fc6460d0960adbe8107d0d33980a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "year"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B657FC6460D0960ADBE8107D0D33980A_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_8cdeed87ce61851c60874c98fc2ae55c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "yday"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 258, 101]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 358);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_8CDEED87CE61851C60874C98FC2AE55C_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_032ccf47ff65db036fbbf8715f468e67(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "wday"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_032CCF47FF65DB036FBBF8715F468E67_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_efd73ab93afbc29b8117d0f5eae3e011(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_EFD73AB93AFBC29B8117D0F5EAE3E011_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1e1ffd2730c0e28b7ed1151e7bdcedee(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_1E1FFD2730C0E28B7ED1151E7BDCEDEE_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_1E1FFD2730C0E28B7ED1151E7BDCEDEE_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_1E1FFD2730C0E28B7ED1151E7BDCEDEE_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_1E1FFD2730C0E28B7ED1151E7BDCEDEE_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_1E1FFD2730C0E28B7ED1151E7BDCEDEE_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dd7502dee22d53d5fae35d9abb703217(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "usec"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_5:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_DD7502DEE22D53D5FAE35D9ABB703217_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_bd0fc7d4b2c70a70b9871b82cb497eba(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_i"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADL", 2, 0, 1]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_4:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_fixnum_value(1300000000);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_5:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_BD0FC7D4B2C70A70B9871B82CB497EBA_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b52b414076aeffa382eeaaf715ea5576(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_f"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_4:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_5:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B52B414076AEFFA382EEAAF715EA5576_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4638d935dc7d7143fae74acaedf7cc91(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 6]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 7);
      NEXT;
    }

  // ["OP_LOADI", 6, 256, 5]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_5:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 6);
      NEXT;
    }

  // ["OP_LOADI", 7, 256, 39]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 40);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 6]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_7:
  {
      int a = 1;
      int n = 6;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_8:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "sec"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 39]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_9:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 40);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_10:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_4638D935DC7D7143FAE74ACAEDF7CC91_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_152b0db8ffc7a9fb7ad74d3c41556327(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "month"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 11]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 12);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_152B0DB8FFC7A9FB7AD74D3C41556327_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_19cd0317af2ad9a4b74f1078797fe697(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "mon"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 11]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 12);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_19CD0317AF2AD9A4B74F1078797FE697_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_898d3518eba48c882a877ef6ef58a996(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_898D3518EBA48C882A877EF6EF58A996_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_898D3518EBA48C882A877EF6EF58A996_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_898D3518EBA48C882A877EF6EF58A996_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_898D3518EBA48C882A877EF6EF58A996_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 6]
  L_MET_898D3518EBA48C882A877EF6EF58A996_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 7);
      NEXT;
    }

  // ["OP_LOADI", 6, 256, 5]
  L_MET_898D3518EBA48C882A877EF6EF58A996_5:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 6);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 5]
  L_MET_898D3518EBA48C882A877EF6EF58A996_6:
  {
      int a = 1;
      int n = 5;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_898D3518EBA48C882A877EF6EF58A996_7:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "min"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 5]
  L_MET_898D3518EBA48C882A877EF6EF58A996_8:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 6);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_898D3518EBA48C882A877EF6EF58A996_9:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_898D3518EBA48C882A877EF6EF58A996_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1ea86c0b3ac7574a85fc007b9c427f88(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "mday"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 22]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 23);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_1EA86C0B3AC7574A85FC007B9C427F88_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_45be0eeb4dfd7e0b9c0564e0dcf3a70d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 4, 0, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[4] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_2:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 3, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[3];
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_4:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 4, 0, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_5:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[4] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_6:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_7:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 2, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_9:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "localtime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_10:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_11:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_12:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "getlocal"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_EQ", 3, 3, 1]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_13:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_45BE0EEB4DFD7E0B9C0564E0DCF3A70D_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_14d2dcdd46be6e8e765409abbd1b8182(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 2, 0, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 3, 0, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[3] = mrb_float_value(7000000.0);
      NEXT;
    }

  // ["OP_SEND", 2, 1, 1]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_2:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 2, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 2, 1, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_4:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 2, 2, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_5:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "clone"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_EQ", 2, 3, 1]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 2;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 2; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_14D2DCDD46BE6E8E765409ABBD1B8182_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4b7662e4e7ded7b9f2b1f5309b1ab122(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 6]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 7);
      NEXT;
    }

  // ["OP_LOADI", 6, 256, 5]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_5:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 6);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 5]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_6:
  {
      int a = 1;
      int n = 5;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_7:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "hour"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 6]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_8:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 7);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_9:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_4B7662E4E7DED7B9F2B1F5309B1AB122_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a0b81409bb56c85a891f2eadc8379f67(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_A0B81409BB56C85A891F2EADC8379F67_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_A0B81409BB56C85A891F2EADC8379F67_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_A0B81409BB56C85A891F2EADC8379F67_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_A0B81409BB56C85A891F2EADC8379F67_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gmtime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_A0B81409BB56C85A891F2EADC8379F67_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f20ee96e7bb60113f90b99ddd4fb5b80(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gmt?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_F20EE96E7BB60113F90B99DDD4FB5B80_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d531b90f1d4da92b209ffa95815deb81(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "getutc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "asctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_D531B90F1D4DA92B209FFA95815DEB81_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a1cdf505cce0eb2de985160d19d778cd(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 5, 0, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[5] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_2:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 4, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[4];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_4:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 5, 0, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_5:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[5] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 4, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_7:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_8:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_9:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "getlocal"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_10:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_11:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_12:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_EQ", 4, 3, 1]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_13:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 4]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_14:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_A1CDF505CCE0EB2DE985160D19D778CD_19;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_15:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_16:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_17:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "getlocal"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_EQ", 4, 3, 1]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_18:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_A1CDF505CCE0EB2DE985160D19D778CD_19:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5075298b7009c845df2df0ee7891b57d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "getgm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "asctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_5075298B7009C845DF2DF0EE7891B57D_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1754bc7343bbfebdd9a29473dcbad29e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_6:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "dst?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 4, 0]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_7:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_1754BC7343BBFEBDD9A29473DCBAD29E_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_cd932e2b13ebb04c5fe4ec4dc043171a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "day"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 22]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 23);
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_CD932E2B13EBB04C5FE4EC4DC043171A_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_06c04114c9d0e2e0bf05c02b90834982(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "ctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_06C04114C9D0E2E0BF05C02B90834982_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4027823873624581c18f80db54cb17fb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_4027823873624581C18F80DB54CB17FB_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_4027823873624581C18F80DB54CB17FB_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_4027823873624581C18F80DB54CB17FB_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_4027823873624581C18F80DB54CB17FB_3:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_4027823873624581C18F80DB54CB17FB_4:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "asctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_4027823873624581C18F80DB54CB17FB_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:06:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_4027823873624581C18F80DB54CB17FB_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_4027823873624581C18F80DB54CB17FB_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_10cb881b642cb7e34e6804e47da2f040(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 5, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[5] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_2:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 4, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[4];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_4:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 5, 0, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_5:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[5] = mrb_float_value(1400000000.0);
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 4, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_7:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[4];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_8:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 5, 0, 2]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_9:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[5] = mrb_float_value(1500000000.0);
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_11:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_13:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_14:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 5, 256, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_15:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 1);
      NEXT;
    }

  // ["OP_EQ", 4, 3, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_16:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 5]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_17:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_10CB881B642CB7E34E6804E47DA2F040_23;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_18:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_19:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_20:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_21:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_EQ", 4, 3, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_22:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 5]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_23:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_10CB881B642CB7E34E6804E47DA2F040_29;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_24:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_25:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_26:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 5, 255, 126]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_27:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], -1);
      NEXT;
    }

  // ["OP_EQ", 4, 3, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_28:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 5]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_29:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_10CB881B642CB7E34E6804E47DA2F040_35;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_30:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_31:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_32:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_33:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_EQ", 4, 3, 1]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_34:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_10CB881B642CB7E34E6804E47DA2F040_35:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_99de27a33cec4915f69bfb362e78fca2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 4, 0, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[4] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_2:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 3, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SUBI", 3, 2, 60]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_5:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 60;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 60;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 60);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_6:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_7:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 3, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_8:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 4, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_9:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "asctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 4, 0, 1]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_10:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:05:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 3, 5, 1]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_99DE27A33CEC4915F69BFB362E78FCA2_12:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_98ff349bd7437e51f2bd0442584526d1(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 4, 0, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[4] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_98FF349BD7437E51F2BD0442584526D1_2:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 3, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_3:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_ADDI", 3, 2, 60]
  L_MET_98FF349BD7437E51F2BD0442584526D1_5:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 60;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 60;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 60);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_6:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_7:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 3, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_8:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 4, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_9:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "asctime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 4, 0, 1]
  L_MET_98FF349BD7437E51F2BD0442584526D1_10:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "Sun Mar 13 07:07:40 UTC 2011");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 3, 5, 1]
  L_MET_98FF349BD7437E51F2BD0442584526D1_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_98FF349BD7437E51F2BD0442584526D1_12:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a57c0c16fce3e207b68d34b7c33f31a5(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "utc"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_A57C0C16FCE3E207B68D34B7C33F31A5_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_21049a88277aef1532ab0ac2c1aadf8b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "now"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_2:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 0]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_3:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_4:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_21049A88277AEF1532AB0AC2C1AADF8B_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2e5441658db21184aeacc067abba8e6a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "mktime"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_2E5441658DB21184AEACC067ABBA8E6A_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c127d8da80f95dc022637de0d6710e84(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "local"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_C127D8DA80F95DC022637DE0D6710E84_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b71aa05047bf88236216cb0e910b585e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_B71AA05047BF88236216CB0E910B585E_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADI", 2, 271, 91]
  L_MET_B71AA05047BF88236216CB0E910B585E_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 2012);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 11]
  L_MET_B71AA05047BF88236216CB0E910B585E_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 12);
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 22]
  L_MET_B71AA05047BF88236216CB0E910B585E_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 23);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 3]
  L_MET_B71AA05047BF88236216CB0E910B585E_4:
  {
      int a = 1;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gm"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B71AA05047BF88236216CB0E910B585E_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0ccad3fdbf6652dcc015863dbe7902b6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_0CCAD3FDBF6652DCC015863DBE7902B6_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_LOADL", 2, 0, 0]
  L_MET_0CCAD3FDBF6652DCC015863DBE7902B6_1:
  {
      /* A Bx   R(A) := Pool(Bx) */
      regs[2] = mrb_float_value(1300000000.0);
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_0CCAD3FDBF6652DCC015863DBE7902B6_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_0CCAD3FDBF6652DCC015863DBE7902B6_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_727b0b666b98e01e29c9b6a056258de7(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_727B0B666B98E01E29C9B6A056258DE7_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_727B0B666B98E01E29C9B6A056258DE7_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "superclass"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_727B0B666B98E01E29C9B6A056258DE7_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_727B0B666B98E01E29C9B6A056258DE7_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_727B0B666B98E01E29C9B6A056258DE7_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_49370cf2a0cd669b15151c7f516ad691(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_49370CF2A0CD669B15151C7F516AD691_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_49370CF2A0CD669B15151C7F516AD691_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 3]
  L_MET_49370CF2A0CD669B15151C7F516AD691_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Class"));
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_49370CF2A0CD669B15151C7F516AD691_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_49370CF2A0CD669B15151C7F516AD691_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_36e70ff1ab501133a0f69794c36c6a5c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 0]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_1:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 2, 0]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_2:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 0]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_3:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_EQ", 1, 3, 1]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_4:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_36E70FF1AB501133A0F69794C36C6A5C_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_8ec17012fe17e80dc1c26911197e8a7f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_8EC17012FE17E80DC1C26911197E8A7F_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_8EC17012FE17E80DC1C26911197E8A7F_1;
      }
      
    }

  // ["OP_GETIV", 2, 0, 0]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_1:
  {
      /* A Bx   R(A) := ivget(Bx) */
      regs[2] = mrb_vm_iv_get(mrb, mrb_intern(mrb, "@c"));
      NEXT;
    }

  // ["OP_JMPIF", 2, 256, 2]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[2])) {
        goto L_MET_8EC17012FE17E80DC1C26911197E8A7F_5;
      }
      NEXT;
    }

  // ["OP_LOADI", 2, 256, 0]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 1);
      NEXT;
    }

  // ["OP_SETIV", 2, 0, 0]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_4:
  {
      /* ivset(Sym(B),R(A)) */
      mrb_vm_iv_set(mrb, mrb_intern(mrb, "@c"), regs[2]);
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_8EC17012FE17E80DC1C26911197E8A7F_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4750e453df4610f2cdd26b012e583c91(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_4750E453DF4610F2CDD26B012E583C91_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_4750E453DF4610F2CDD26B012E583C91_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_8ec17012fe17e80dc1c26911197e8a7f, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_8ec17012fe17e80dc1c26911197e8a7f);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_4750E453DF4610F2CDD26B012E583C91_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "b"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_4750E453DF4610F2CDD26B012E583C91_3:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_4750E453DF4610F2CDD26B012E583C91_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dca9ad52c6ac2ad02ec1b09f4faa5b4f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_DCA9AD52C6AC2AD02EC1B09F4FAA5B4F_0:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_MET_DCA9AD52C6AC2AD02EC1B09F4FAA5B4F_1:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 0, 0]
  L_MET_DCA9AD52C6AC2AD02EC1B09F4FAA5B4F_2:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "A");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 1]
  L_MET_DCA9AD52C6AC2AD02EC1B09F4FAA5B4F_3:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_4750e453df4610f2cdd26b012e583c91);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_4750e453df4610f2cdd26b012e583c91]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_DCA9AD52C6AC2AD02EC1B09F4FAA5B4F_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_41b2a821128decc5b6b1fea594c4569b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_0:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 0, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_1:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Syntax4AbbrVarAsgnAsReturns");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 1]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_2:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_dca9ad52c6ac2ad02ec1b09f4faa5b4f);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_dca9ad52c6ac2ad02ec1b09f4faa5b4f]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_3:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Syntax4AbbrVarAsgnAsReturns"));
      NEXT;
    }

  // ["OP_GETMCNST", 1, 0, 1]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_4:
  {
      /* A B C  R(A) := R(C)::Sym(B) */
      int a = 1;

      regs[a] = mrb_const_get(mrb, regs[a], mrb_intern(mrb, "A"));
      NEXT;
    }

  // ["OP_SEND", 1, 2, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_5:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 3, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_6:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "b"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 2, 256, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_7:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 1);
      NEXT;
    }

  // ["OP_EQ", 1, 4, 1]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_8:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_41B2A821128DECC5B6B1FEA594C4569B_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_6054d273d8b302b372572ad698775bfb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_6054D273D8B302B372572AD698775BFB_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_6054D273D8B302B372572AD698775BFB_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_6054D273D8B302B372572AD698775BFB_1;
      }
      
    }

  // ["OP_GETCONST", 0, 0, 0]
  L_MET_6054D273D8B302B372572AD698775BFB_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[0] = mrb_vm_const_get(mrb, mrb_intern(mrb, "CONST1"));
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_6054D273D8B302B372572AD698775BFB_2:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_faa1e426539cce7742403976b7c7453b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_FAA1E426539CCE7742403976B7C7453B_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_FAA1E426539CCE7742403976B7C7453B_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_6054d273d8b302b372572ad698775bfb, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_6054d273d8b302b372572ad698775bfb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_FAA1E426539CCE7742403976B7C7453B_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "const1"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_FAA1E426539CCE7742403976B7C7453B_3:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_FAA1E426539CCE7742403976B7C7453B_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_20ebbedf19f0490ff60ea65b180d3834(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_STRING", 1, 0, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_0:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[1] = mrb_str_new_cstr(mrb, "hello world");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SETCONST", 1, 0, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_1:
  {
      /* A B    constset(Sym(B),R(A)) */
      mrb_vm_const_set(mrb, mrb_intern(mrb, "CONST1"), regs[1]);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_2:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_3:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 1, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_4:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Const2");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 1]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_5:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_faa1e426539cce7742403976b7c7453b);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_faa1e426539cce7742403976b7c7453b]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_20EBBEDF19F0490FF60EA65B180D3834_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1833288fb63445a1d38c312cafc90a9f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_0:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_1:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Syntax4Const");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 1]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_2:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_20ebbedf19f0490ff60ea65b180d3834);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_20ebbedf19f0490ff60ea65b180d3834]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_3:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Syntax4Const"));
      NEXT;
    }

  // ["OP_GETMCNST", 1, 0, 1]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_4:
  {
      /* A B C  R(A) := R(C)::Sym(B) */
      int a = 1;

      regs[a] = mrb_const_get(mrb, regs[a], mrb_intern(mrb, "CONST1"));
      NEXT;
    }

  // ["OP_STRING", 2, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "hello world");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_6:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 1, 256, 6]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_1833288FB63445A1D38C312CAFC90A9F_14;
      }
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_8:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Syntax4Const"));
      NEXT;
    }

  // ["OP_GETMCNST", 1, 0, 3]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_9:
  {
      /* A B C  R(A) := R(C)::Sym(B) */
      int a = 1;

      regs[a] = mrb_const_get(mrb, regs[a], mrb_intern(mrb, "Const2"));
      NEXT;
    }

  // ["OP_SEND", 1, 4, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_10:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 1, 5, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_11:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const1"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 2, 0, 1]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_12:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "hello world");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 1, 2, 1]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_13:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 1;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 1; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_1833288FB63445A1D38C312CAFC90A9F_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_7cf4f6b9817a7fe01a139216dbfcc8a8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_MOVE", 4, 1, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_0:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_JMPIF", 4, 256, 1]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_1:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_3;
      }
      NEXT;
    }

  // ["OP_LOADI", 1, 256, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[1], 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 1]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_6;
      }
      NEXT;
    }

  // ["OP_LOADI", 2, 256, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_5:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 1);
      NEXT;
    }

  // ["OP_LOADI", 3, 256, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_7:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 4, 0, 2]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_8:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 4;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 2;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 2;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 2);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_9:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_11:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 1);
      NEXT;
    }

  // ["OP_EQ", 4, 1, 1]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 3]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_17;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_14:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_15:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_EQ", 4, 1, 1]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_16:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 3]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_17:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_21;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_18:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 2]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_19:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 3);
      NEXT;
    }

  // ["OP_EQ", 4, 1, 1]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_20:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_7CF4F6B9817A7FE01A139216DBFCC8A8_21:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4e31f578537489f74270e3ba8e855c40(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ONERR", 0, 256, 3]
  L_MET_4E31F578537489F74270E3BA8E855C40_0:
  {
      /* sBx    pc+=sBx on exception */
      jmp_buf c_jmp;
      if (setjmp(c_jmp) == 0) {
        mrb->jmp = &c_jmp;
        if (mrb->rsize <= mrb->ci->ridx) {
          if (mrb->rsize == 0) mrb->rsize = 16;
          else mrb->rsize *= 2;
          mrb->rescue = (mrb_code **)mrb_realloc(mrb, mrb->rescue, sizeof(mrb_code*) * mrb->rsize);
        }
        mrb->rescue[mrb->ci->ridx++] = &c_jmp;
      }
      else {
        mrb->ci->ridx--;
        mrb->jmp = (jmp_buf *)mrb->rescue[mrb->ci->ridx-1];
        goto L_MET_4E31F578537489F74270E3BA8E855C40_4;
      }

      NEXT;
    }

  // ["OP_BLKPUSH", 1, 0, 3]
  L_MET_4E31F578537489F74270E3BA8E855C40_1:
  {
      /* A Bx   R(A) := block (16=6:1:5:4) */
      int a = 1;
      int bx = 3;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
  if (!e) {
    localjump_error(mrb, "yield");
    mrbb_raise(mrb, prev_jmp);
  }
        stack = e->stack + 1;
      }
      regs[a] = stack[m1+r+m2];
      NEXT;
    }

  // ["OP_SEND", 1, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_2:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 9]
  L_MET_4E31F578537489F74270E3BA8E855C40_3:
  goto L_MET_4E31F578537489F74270E3BA8E855C40_13;
  // ["OP_RESCUE", 1, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_4:
  { // TODO
      /* A      R(A) := exc; clear(exc) */
      mrb->ci = ci;
      SET_OBJ_VALUE(regs[1], mrb->exc);
      mrb->exc = 0;
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_4E31F578537489F74270E3BA8E855C40_5:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "LocalJumpError"));
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 2, 2, 1]
  L_MET_4E31F578537489F74270E3BA8E855C40_7:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "==="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPIF", 2, 256, 1]
  L_MET_4E31F578537489F74270E3BA8E855C40_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[2])) {
        goto L_MET_4E31F578537489F74270E3BA8E855C40_10;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_4E31F578537489F74270E3BA8E855C40_9:
  goto L_MET_4E31F578537489F74270E3BA8E855C40_12;
  // ["OP_LOADT", 1, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_10:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_4E31F578537489F74270E3BA8E855C40_11:
  goto L_MET_4E31F578537489F74270E3BA8E855C40_15;
  // ["OP_RAISE", 1, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_12:
  {
      /* A      raise(R(A)) */
      mrb->exc = (struct RObject*)mrb_object(regs[1]);
      mrbb_raise(mrb, prev_jmp);
    }

  // ["OP_POPERR", 1, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_13:
  {
      int a = 1;

      while (a--) {
        mrb->ci->ridx--;
      }
      NEXT;
    }

  // ["OP_LOADF", 2, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_14:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_4E31F578537489F74270E3BA8E855C40_15:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_825b09c1457dd91659e1730d3bf31055(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_825B09C1457DD91659E1730D3BF31055_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_825B09C1457DD91659E1730D3BF31055_1;
      }
      
    }

  // ["OP_ARRAY", 4, 4, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 4, 5, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_3:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[4],
                     mrb_ary_splat(mrb, regs[5]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_4:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SUPER", 3, 0, 127]
  L_MET_825B09C1457DD91659E1730D3BF31055_5:
  {
      /* A B C  R(A) := super(R(A+1),... ,R(A+C-1)) */
      mrb_value recv;
      mrb_callinfo *ci = mrb->ci;
      struct RProc *m;
      struct RClass *c;
      mrb_sym mid = ci->mid;
      int a = 3;
      int n = 127;

      recv = regs[0];
      c = mrb->ci->target_class->super;
      m = mrb_method_search_vm(mrb, &c, mid);
      if (!m) {
        mid = mrb_intern(mrb, "method_missing");
        m = mrb_method_search_vm(mrb, &c, mid);
        if (n == CALL_MAXARGS) {
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));
        }
        else {
          memmove(regs+a+2, regs+a+1, sizeof(mrb_value)*(n+1));
    SET_SYM_VALUE(regs[a+1], ci->mid);
          n++;
        }
      }

      /* push callinfo */
      ci = cipush(mrb);
      ci->mid = mid;
      ci->proc = m;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = n;
      if (ci->argc == CALL_MAXARGS) ci->argc = -1;
      ci->target_class = m->target_class;
      //ci->pc = pc + 1;

      /* prepare stack */
      mrb->stack += a;
      mrb->stack[0] = recv;

      if (MRB_PROC_CFUNC_P(m)) {
        mrb->stack[0] = m->body.func(mrb, recv);
        mrb->arena_idx = ai;
        if (mrb->exc) mrbb_raise(mrb, prev_jmp);
        /* pop stackpos */
        regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
        cipop(mrb);
        NEXT;
      }
      else {
        printf("TODO SUPER 2 MRB\n");
        exit(0);
      }
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_825B09C1457DD91659E1730D3BF31055_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f50723649d63025b5744af858fc5c36e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_F50723649D63025B5744AF858FC5C36E_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F50723649D63025B5744AF858FC5C36E_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F50723649D63025B5744AF858FC5C36E_1;
      }
      
    }

  // ["OP_ARGARY", 3, 0, 0]
  L_MET_F50723649D63025B5744AF858FC5C36E_1:
  {
      /* A Bx   R(A) := argument array (16=6:1:5:4) */
      int a = 3;
      int bx = 0;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
        if (!e) {
          mrb_value exc;
          static const char m[] = "super called outside of method";
          exc = mrb_exc_new(mrb, E_NOMETHOD_ERROR, m, sizeof(m) - 1);
          mrb->exc = (struct RObject*)mrb_object(exc);
          mrbb_raise(mrb, prev_jmp);
        }
        stack = e->stack + 1;
      }
      if (r == 0) {
        regs[a] = mrb_ary_new_elts(mrb, m1+m2, stack);
      }
      else {
        mrb_value *pp = NULL;
        struct RArray *rest;
        int len = 0;

        if (mrb_array_p(stack[m1])) {
          struct RArray *ary = mrb_ary_ptr(stack[m1]);

          pp = ary->ptr;
          len = ary->len;
        }
        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);
        rest = mrb_ary_ptr(regs[a]);
        stack_copy(rest->ptr, stack, m1);
        if (len > 0) {
          stack_copy(rest->ptr+m1, pp, len);
        }
        if (m2 > 0) {
          stack_copy(rest->ptr+m1+len, stack+m1+1, m2);
        }
        rest->len = m1+len+m2;
      }
      regs[a+1] = stack[m1+r+m2];
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SUPER", 2, 0, 127]
  L_MET_F50723649D63025B5744AF858FC5C36E_2:
  {
      /* A B C  R(A) := super(R(A+1),... ,R(A+C-1)) */
      mrb_value recv;
      mrb_callinfo *ci = mrb->ci;
      struct RProc *m;
      struct RClass *c;
      mrb_sym mid = ci->mid;
      int a = 2;
      int n = 127;

      recv = regs[0];
      c = mrb->ci->target_class->super;
      m = mrb_method_search_vm(mrb, &c, mid);
      if (!m) {
        mid = mrb_intern(mrb, "method_missing");
        m = mrb_method_search_vm(mrb, &c, mid);
        if (n == CALL_MAXARGS) {
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));
        }
        else {
          memmove(regs+a+2, regs+a+1, sizeof(mrb_value)*(n+1));
    SET_SYM_VALUE(regs[a+1], ci->mid);
          n++;
        }
      }

      /* push callinfo */
      ci = cipush(mrb);
      ci->mid = mid;
      ci->proc = m;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = n;
      if (ci->argc == CALL_MAXARGS) ci->argc = -1;
      ci->target_class = m->target_class;
      //ci->pc = pc + 1;

      /* prepare stack */
      mrb->stack += a;
      mrb->stack[0] = recv;

      if (MRB_PROC_CFUNC_P(m)) {
        mrb->stack[0] = m->body.func(mrb, recv);
        mrb->arena_idx = ai;
        if (mrb->exc) mrbb_raise(mrb, prev_jmp);
        /* pop stackpos */
        regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
        cipop(mrb);
        NEXT;
      }
      else {
        printf("TODO SUPER 2 MRB\n");
        exit(0);
      }
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_F50723649D63025B5744AF858FC5C36E_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d14a0880e4afe2edcda7cc363dc7bd69(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f50723649d63025b5744af858fc5c36e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f50723649d63025b5744af858fc5c36e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "foo"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_825b09c1457dd91659e1730d3bf31055, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_825b09c1457dd91659e1730d3bf31055);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "bar"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_6:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D14A0880E4AFE2EDCDA7CC363DC7BD69_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b592761d151a8f94ceedc430ce91e653(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_B592761D151A8F94CEEDC430CE91E653_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_B592761D151A8F94CEEDC430CE91E653_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_B592761D151A8F94CEEDC430CE91E653_1;
      }
      
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_B592761D151A8F94CEEDC430CE91E653_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_15611f08a212702876adc6a722180ebb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_15611F08A212702876ADC6A722180EBB_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_15611F08A212702876ADC6A722180EBB_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_15611F08A212702876ADC6A722180EBB_1;
      }
      
    }

  // ["OP_LOADT", 0, 0, 0]
  L_MET_15611F08A212702876ADC6A722180EBB_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[0]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_15611F08A212702876ADC6A722180EBB_2:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_38b415e618b8b729d66ec925d7398f52(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_38B415E618B8B729D66EC925D7398F52_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_15611f08a212702876adc6a722180ebb, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_15611f08a212702876adc6a722180ebb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "foo"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_38B415E618B8B729D66EC925D7398F52_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b592761d151a8f94ceedc430ce91e653, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b592761d151a8f94ceedc430ce91e653);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "bar"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_6:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_38B415E618B8B729D66EC925D7398F52_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5a17bba0f19b4dc0b1d9b3c1dddc44f5(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADF", 1, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_0:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_ONERR", 0, 256, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_1:
  {
      /* sBx    pc+=sBx on exception */
      jmp_buf c_jmp;
      if (setjmp(c_jmp) == 0) {
        mrb->jmp = &c_jmp;
        if (mrb->rsize <= mrb->ci->ridx) {
          if (mrb->rsize == 0) mrb->rsize = 16;
          else mrb->rsize *= 2;
          mrb->rescue = (mrb_code **)mrb_realloc(mrb, mrb->rescue, sizeof(mrb_code*) * mrb->rsize);
        }
        mrb->rescue[mrb->ci->ridx++] = &c_jmp;
      }
      else {
        mrb->ci->ridx--;
        mrb->jmp = (jmp_buf *)mrb->rescue[mrb->ci->ridx-1];
        goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_5;
      }

      NEXT;
    }

  // ["OP_ARGARY", 4, 0, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_2:
  {
      /* A Bx   R(A) := argument array (16=6:1:5:4) */
      int a = 4;
      int bx = 3;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
        if (!e) {
          mrb_value exc;
          static const char m[] = "super called outside of method";
          exc = mrb_exc_new(mrb, E_NOMETHOD_ERROR, m, sizeof(m) - 1);
          mrb->exc = (struct RObject*)mrb_object(exc);
          mrbb_raise(mrb, prev_jmp);
        }
        stack = e->stack + 1;
      }
      if (r == 0) {
        regs[a] = mrb_ary_new_elts(mrb, m1+m2, stack);
      }
      else {
        mrb_value *pp = NULL;
        struct RArray *rest;
        int len = 0;

        if (mrb_array_p(stack[m1])) {
          struct RArray *ary = mrb_ary_ptr(stack[m1]);

          pp = ary->ptr;
          len = ary->len;
        }
        regs[a] = mrb_ary_new_capa(mrb, m1+len+m2);
        rest = mrb_ary_ptr(regs[a]);
        stack_copy(rest->ptr, stack, m1);
        if (len > 0) {
          stack_copy(rest->ptr+m1, pp, len);
        }
        if (m2 > 0) {
          stack_copy(rest->ptr+m1+len, stack+m1+1, m2);
        }
        rest->len = m1+len+m2;
      }
      regs[a+1] = stack[m1+r+m2];
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SUPER", 3, 0, 127]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_3:
  {
      /* A B C  R(A) := super(R(A+1),... ,R(A+C-1)) */
      mrb_value recv;
      mrb_callinfo *ci = mrb->ci;
      struct RProc *m;
      struct RClass *c;
      mrb_sym mid = ci->mid;
      int a = 3;
      int n = 127;

      recv = regs[0];
      c = mrb->ci->target_class->super;
      m = mrb_method_search_vm(mrb, &c, mid);
      if (!m) {
        mid = mrb_intern(mrb, "method_missing");
        m = mrb_method_search_vm(mrb, &c, mid);
        if (n == CALL_MAXARGS) {
          mrb_ary_unshift(mrb, regs[a+1], mrb_symbol_value(ci->mid));
        }
        else {
          memmove(regs+a+2, regs+a+1, sizeof(mrb_value)*(n+1));
    SET_SYM_VALUE(regs[a+1], ci->mid);
          n++;
        }
      }

      /* push callinfo */
      ci = cipush(mrb);
      ci->mid = mid;
      ci->proc = m;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = n;
      if (ci->argc == CALL_MAXARGS) ci->argc = -1;
      ci->target_class = m->target_class;
      //ci->pc = pc + 1;

      /* prepare stack */
      mrb->stack += a;
      mrb->stack[0] = recv;

      if (MRB_PROC_CFUNC_P(m)) {
        mrb->stack[0] = m->body.func(mrb, recv);
        mrb->arena_idx = ai;
        if (mrb->exc) mrbb_raise(mrb, prev_jmp);
        /* pop stackpos */
        regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
        cipop(mrb);
        NEXT;
      }
      else {
        printf("TODO SUPER 2 MRB\n");
        exit(0);
      }
    }

  // ["OP_JMP", 0, 256, 9]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_4:
  goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_14;
  // ["OP_RESCUE", 3, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_5:
  { // TODO
      /* A      R(A) := exc; clear(exc) */
      mrb->ci = ci;
      SET_OBJ_VALUE(regs[3], mrb->exc);
      mrb->exc = 0;
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_6:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NoMethodError"));
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_7:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_8:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "==="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPIF", 4, 256, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_11;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_10:
  goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_13;
  // ["OP_LOADT", 1, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_11:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[1]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_12:
  goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_15;
  // ["OP_RAISE", 3, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_13:
  {
      /* A      raise(R(A)) */
      mrb->exc = (struct RObject*)mrb_object(regs[3]);
      mrbb_raise(mrb, prev_jmp);
    }

  // ["OP_POPERR", 1, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_14:
  {
      int a = 1;

      while (a--) {
        mrb->ci->ridx--;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_15:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_16:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 3, 2, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_17:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 3;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "SuperFoo");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 3, 0, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_18:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 3;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_38b415e618b8b729d66ec925d7398f52);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_38b415e618b8b729d66ec925d7398f52]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_19:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 2]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_20:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "SuperFoo"));
      NEXT;
    }

  // ["OP_CLASS", 3, 3, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_21:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 3;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "SuperBar");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 3, 0, 4]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_22:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 3;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_d14a0880e4afe2edcda7cc363dc7bd69);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_d14a0880e4afe2edcda7cc363dc7bd69]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_23:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "SuperBar"));
      NEXT;
    }

  // ["OP_SEND", 3, 4, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_24:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_25:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_26:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_27:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_31;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_28:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 5, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_29:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "foo"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 3, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_30:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_31:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 11]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_32:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_44;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_33:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_LOADI", 4, 256, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_34:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 1);
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_35:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 2);
      NEXT;
    }

  // ["OP_LOADI", 6, 256, 2]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_36:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 3);
      NEXT;
    }

  // ["OP_SEND", 3, 6, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_37:
  {
      int a = 3;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "bar"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 256, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_38:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 1);
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_39:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 2);
      NEXT;
    }

  // ["OP_LOADI", 6, 256, 2]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_40:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 3);
      NEXT;
    }

  // ["OP_ARRAY", 4, 4, 3]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_41:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 3, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EQ", 3, 7, 1]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_42:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_MOVE", 1, 3, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_43:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[3];
      NEXT;
    }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_5A17BBA0F19B4DC0B1D9B3C1DDDC44F5_44:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3b0156252f97092a27796ee279bb3251(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 8, 0, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 524288;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_3B0156252F97092A27796EE279BB3251_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_3B0156252F97092A27796EE279BB3251_1;
      }
      
    }

  // ["OP_GETCONST", 5, 0, 1]
  L_MET_3B0156252F97092A27796EE279BB3251_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[5] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Math"));
      NEXT;
    }

  // ["OP_GETMCNST", 5, 0, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_2:
  {
      /* A B C  R(A) := R(C)::Sym(B) */
      int a = 5;

      regs[a] = mrb_const_get(mrb, regs[a], mrb_intern(mrb, "TOLERANCE"));
      NEXT;
    }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_4:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_5:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_f"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 5, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_6:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_7:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_8:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_f"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 5, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_9:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 3, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_11:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "finite?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 2]
  L_MET_3B0156252F97092A27796EE279BB3251_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_3B0156252F97092A27796EE279BB3251_15;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_13:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 3, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_14:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "finite?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 7]
  L_MET_3B0156252F97092A27796EE279BB3251_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_3B0156252F97092A27796EE279BB3251_23;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_16:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_17:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SUB", 5, 4, 1]
  L_MET_3B0156252F97092A27796EE279BB3251_18:
  {
      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/
      int a = 5;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x - y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x - y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(-,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(-,attr_f,attr_f);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SEND", 5, 5, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_19:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "abs"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_20:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_LT", 5, 6, 1]
  L_MET_3B0156252F97092A27796EE279BB3251_21:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_3B0156252F97092A27796EE279BB3251_22:
  goto L_MET_3B0156252F97092A27796EE279BB3251_24;
  // ["OP_LOADT", 5, 0, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_23:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[5]);
      NEXT;
    }

  // ["OP_RETURN", 5, 0, 0]
  L_MET_3B0156252F97092A27796EE279BB3251_24:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[5];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4efdb584ca5438f90035d53b1c2e90b8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (9 < 3) ? 3 : 9, 3);
  }
  else {
    stack_extend(mrb, 9, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 9 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 16, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1048576;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_4EFDB584CA5438F90035D53B1C2E90B8_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_4EFDB584CA5438F90035D53B1C2E90B8_1;
      }
      
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_1:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_2:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 0, 1]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_3:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_4:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 2, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_5:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 8, 3, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_6:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 6, 1, 2]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_7:
  {
      int a = 6;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print_assertion_string"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_8:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_JMPNOT", 6, 256, 7]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_4EFDB584CA5438F90035D53B1C2E90B8_17;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_10:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 7, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_11:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, " => ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 0, 1]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_12:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_13:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 4, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_14:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 7, 2, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_15:
  {
      int a = 7;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "message"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 0, 1]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_16:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_17:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 7, 0, 1]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_18:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 0, 1]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_19:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 6, 0, 0]
  L_MET_4EFDB584CA5438F90035D53B1C2E90B8_20:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[6];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c2a47b6fbb506f8ea8ba37dbf6137507(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_2:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_3:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETGLOBAL", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_4:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[2] = mrb_gv_get(mrb, mrb_intern(mrb, "$asserts"));
      NEXT;
    }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_5:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4efdb584ca5438f90035d53b1c2e90b8, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_4efdb584ca5438f90035d53b1c2e90b8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 2, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_6:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETGLOBAL", 2, 0, 3]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_7:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[2] = mrb_gv_get(mrb, mrb_intern(mrb, "$ok_test"));
      NEXT;
    }

  // ["OP_GETGLOBAL", 3, 0, 5]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_8:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[3] = mrb_gv_get(mrb, mrb_intern(mrb, "$ko_test"));
      NEXT;
    }

  // ["OP_ADD", 2, 4, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_9:
  {
      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/
      int a = 2;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x + y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x + y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(+,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(+,attr_f,attr_f);
  break;
      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
  regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SETGLOBAL", 2, 0, 6]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_10:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$total_test"), regs[2]);
      NEXT;
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_11:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_12:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "Total: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_13:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_14:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETGLOBAL", 3, 0, 6]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_15:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[3] = mrb_gv_get(mrb, mrb_intern(mrb, "$total_test"));
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_16:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_17:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 2]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_18:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_19:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_20:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 3]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_21:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "   OK: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_22:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_23:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETGLOBAL", 3, 0, 3]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_24:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[3] = mrb_gv_get(mrb, mrb_intern(mrb, "$ok_test"));
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_25:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_26:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 4]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_27:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_28:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_29:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 5]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_30:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "   KO: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_31:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_32:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETGLOBAL", 3, 0, 5]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_33:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[3] = mrb_gv_get(mrb, mrb_intern(mrb, "$ko_test"));
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_34:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_35:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 6]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_36:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_37:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_38:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 7]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_39:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "Crash: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_40:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_41:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETGLOBAL", 3, 0, 7]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_42:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[3] = mrb_gv_get(mrb, mrb_intern(mrb, "$kill_test"));
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_43:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_44:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 8]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_45:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_46:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 2, 0, 8]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_47:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 10]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_48:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 2, 9, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_49:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 2, 256, 13]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_50:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[2])) {
        goto L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_64;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_51:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 9]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_52:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, " Time: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_53:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_54:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 10]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_55:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 3, 11, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_56:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "now"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETGLOBAL", 4, 0, 13]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_57:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[4] = mrb_gv_get(mrb, mrb_intern(mrb, "$test_start"));
      NEXT;
    }

  // ["OP_SUB", 3, 12, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_58:
  {
      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/
      int a = 3;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x - y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x - y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(-,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(-,attr_f,attr_f);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_59:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_60:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 3, 0, 10]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_61:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, " seconds\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 0, 1]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_62:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_63:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_C2A47B6FBB506F8EA8BA37DBF6137507_64:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ea1a28002a327accdd5661ce755da16a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (10 < 3) ? 3 : 10, 3);
  }
  else {
    stack_extend(mrb, 10, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 10 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 128, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 16384;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
  
    switch(argc) {
  case 0: goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_1;
  case 1: goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_2;
}

      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_3;
      }
      
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_1:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_4;
  // ["OP_JMP", 0, 256, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_2:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_5;
  // ["OP_JMP", 0, 256, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_3:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_6;
  // ["OP_STRING", 1, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_4:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[1] = mrb_str_new_cstr(mrb, "Assertion failed");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 2, 0, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_ONERR", 0, 256, 24]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_6:
  {
      /* sBx    pc+=sBx on exception */
      jmp_buf c_jmp;
      if (setjmp(c_jmp) == 0) {
        mrb->jmp = &c_jmp;
        if (mrb->rsize <= mrb->ci->ridx) {
          if (mrb->rsize == 0) mrb->rsize = 16;
          else mrb->rsize *= 2;
          mrb->rescue = (mrb_code **)mrb_realloc(mrb, mrb->rescue, sizeof(mrb_code*) * mrb->rsize);
        }
        mrb->rescue[mrb->ci->ridx++] = &c_jmp;
      }
      else {
        mrb->ci->ridx--;
        mrb->jmp = (jmp_buf *)mrb->rescue[mrb->ci->ridx-1];
        goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_31;
      }

      NEXT;
    }

  // ["OP_BLKPUSH", 5, 16, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_7:
  {
      /* A Bx   R(A) := block (16=6:1:5:4) */
      int a = 5;
      int bx = 2048;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
  if (!e) {
    localjump_error(mrb, "yield");
    mrbb_raise(mrb, prev_jmp);
  }
        stack = e->stack + 1;
      }
      regs[a] = stack[m1+r+m2];
      NEXT;
    }

  // ["OP_SEND", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_8:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 5, 1, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_9:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 13]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_10:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_24;
      }
      NEXT;
    }

  // ["OP_GETGLOBAL", 5, 0, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_11:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[5] = mrb_gv_get(mrb, mrb_intern(mrb, "$asserts"));
      NEXT;
    }

  // ["OP_STRING", 6, 0, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_12:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "Fail: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_13:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_14:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_ARRAY", 6, 6, 3]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_15:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[6] = mrb_ary_new_from_values(mrb, 3, &regs[6]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 3, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_16:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETGLOBAL", 5, 0, 4]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_17:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[5] = mrb_gv_get(mrb, mrb_intern(mrb, "$ko_test"));
      NEXT;
    }

  // ["OP_ADDI", 5, 5, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_18:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETGLOBAL", 5, 0, 4]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_19:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$ko_test"), regs[5]);
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_20:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 6, 0, 3]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_21:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "F");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 6, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_22:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 6]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_23:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_30;
  // ["OP_GETGLOBAL", 5, 0, 7]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_24:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[5] = mrb_gv_get(mrb, mrb_intern(mrb, "$ok_test"));
      NEXT;
    }

  // ["OP_ADDI", 5, 5, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_25:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETGLOBAL", 5, 0, 7]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_26:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$ok_test"), regs[5]);
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_27:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 6, 0, 4]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_28:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, ".");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 6, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_29:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 22]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_30:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_53;
  // ["OP_RESCUE", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_31:
  { // TODO
      /* A      R(A) := exc; clear(exc) */
      mrb->ci = ci;
      SET_OBJ_VALUE(regs[5], mrb->exc);
      mrb->exc = 0;
      NEXT;
    }

  // ["OP_GETCONST", 6, 0, 8]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_32:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Exception"));
      NEXT;
    }

  // ["OP_MOVE", 7, 5, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_33:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[5];
      NEXT;
    }

  // ["OP_SEND", 6, 9, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_34:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "==="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPIF", 6, 256, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_35:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[6])) {
        goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_37;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 15]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_36:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_52;
  // ["OP_MOVE", 4, 5, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_37:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_GETGLOBAL", 5, 0, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_38:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[5] = mrb_gv_get(mrb, mrb_intern(mrb, "$asserts"));
      NEXT;
    }

  // ["OP_STRING", 6, 0, 5]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_39:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "Error: ");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_40:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_41:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 9, 4, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_42:
  {
      /* A B    R(A) := R(B) */
      regs[9] = regs[4];
      NEXT;
    }

  // ["OP_ARRAY", 6, 6, 4]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_43:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[6] = mrb_ary_new_from_values(mrb, 4, &regs[6]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 3, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_44:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETGLOBAL", 5, 0, 10]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_45:
  {
      /* A B    R(A) := getglobal(Sym(B)) */
      regs[5] = mrb_gv_get(mrb, mrb_intern(mrb, "$kill_test"));
      NEXT;
    }

  // ["OP_ADDI", 5, 5, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_46:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETGLOBAL", 5, 0, 10]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_47:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$kill_test"), regs[5]);
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_48:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 6, 0, 6]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_49:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "X");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 6, 1]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_50:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 2]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_51:
  goto L_MET_EA1A28002A327ACCDD5661CE755DA16A_54;
  // ["OP_RAISE", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_52:
  {
      /* A      raise(R(A)) */
      mrb->exc = (struct RObject*)mrb_object(regs[5]);
      mrbb_raise(mrb, prev_jmp);
    }

  // ["OP_POPERR", 1, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_53:
  {
      int a = 1;

      while (a--) {
        mrb->ci->ridx--;
      }
      NEXT;
    }

  // ["OP_RETURN", 5, 0, 0]
  L_MET_EA1A28002A327ACCDD5661CE755DA16A_54:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[5];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c16e0e25b79c980c135083c5add3d174(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 8, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 524288;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_C16E0E25B79C980C135083C5ADD3D174_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_C16E0E25B79C980C135083C5ADD3D174_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_5:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 10]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_C16E0E25B79C980C135083C5ADD3D174_18;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_8:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 5, 0, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_9:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, " [");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_11:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_12:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_13:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_14:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 5, 0, 2]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_15:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "]");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_16:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "print"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_17:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_C16E0E25B79C980C135083C5ADD3D174_18:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_7d93c20789ad17df031130eb34708b7a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_7D93C20789AD17DF031130EB34708B7A_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_7D93C20789AD17DF031130EB34708B7A_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_7D93C20789AD17DF031130EB34708B7A_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_7D93C20789AD17DF031130EB34708B7A_7:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 4]
  L_MET_7D93C20789AD17DF031130EB34708B7A_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_7D93C20789AD17DF031130EB34708B7A_13;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 2, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_9:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_7D93C20789AD17DF031130EB34708B7A_11:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_12:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_7D93C20789AD17DF031130EB34708B7A_13:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b7dfc5c79bf41458e69d8af9d627bf26(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_3:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 1, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "members"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_5:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_7d93c20789ad17df031130eb34708b7a, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_7d93c20789ad17df031130eb34708b7a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 2, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_B7DFC5C79BF41458E69D8AF9D627BF26_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_82313c9fde7fdad843ac07a0e5efdab1(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_3:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_sym"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_4:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_5:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 1]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_6:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 2]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_7:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_82313C9FDE7FDAD843AC07A0E5EFDAB1_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_afb42eb81e334b206c2536db5ae6e52d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_AFB42EB81E334B206C2536DB5AE6E52D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_AFB42EB81E334B206C2536DB5AE6E52D_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_2:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 2, 1, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_3:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "members"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_82313c9fde7fdad843ac07a0e5efdab1, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_82313c9fde7fdad843ac07a0e5efdab1);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 2, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_5:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_6:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_AFB42EB81E334B206C2536DB5AE6E52D_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0f5bc6bed3c92ea61446541680f2962a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0F5BC6BED3C92EA61446541680F2962A_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0F5BC6BED3C92EA61446541680F2962A_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_0F5BC6BED3C92EA61446541680F2962A_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1de209716d0f72ab39630c0ef87d9f90(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_1DE209716D0F72AB39630C0EF87D9F90_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_1DE209716D0F72AB39630C0EF87D9F90_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_2:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "class"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 2, 1, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_3:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "members"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0f5bc6bed3c92ea61446541680f2962a, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_0f5bc6bed3c92ea61446541680f2962a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 2, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_5:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_6:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_1DE209716D0F72AB39630C0EF87D9F90_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_349e3e5266f4969995a6f148801aa20b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_349E3E5266F4969995A6F148801AA20B_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1de209716d0f72ab39630c0ef87d9f90, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1de209716d0f72ab39630c0ef87d9f90);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_349E3E5266F4969995A6F148801AA20B_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_afb42eb81e334b206c2536db5ae6e52d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_afb42eb81e334b206c2536db5ae6e52d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_pair"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 21]
  L_MET_349E3E5266F4969995A6F148801AA20B_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b7dfc5c79bf41458e69d8af9d627bf26, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b7dfc5c79bf41458e69d8af9d627bf26);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "select"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_9:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_349E3E5266F4969995A6F148801AA20B_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b238a0163abaec5335665cfa1485ee9f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_B238A0163ABAEC5335665CFA1485EE9F_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_B238A0163ABAEC5335665CFA1485EE9F_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Comparable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_B238A0163ABAEC5335665CFA1485EE9F_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_B238A0163ABAEC5335665CFA1485EE9F_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3dfe782fc0a622f1fd2ca633d5e6e445(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_3DFE782FC0A622F1FD2CA633D5E6E445_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_3DFE782FC0A622F1FD2CA633D5E6E445_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_7eda5c36f56fdd4a6daa4014ef3540a9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (10 < 3) ? 3 : 10, 3);
  }
  else {
    stack_extend(mrb, 10, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 10 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 8, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 524288;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_1;
      }
      
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_1:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 127]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_2:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 0);
      NEXT;
    }

  // ["OP_MOVE", 8, 1, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_3:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 0, 2]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_4:
  {
      int a = 6;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 6, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[6];
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_6:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_7:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_ADDI", 7, 1, 1]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_8:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 7;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_LOADI", 8, 255, 126]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_9:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[8], -1);
      NEXT;
    }

  // ["OP_RANGE", 7, 7, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_10:
  {
      /* A B C  R(A) := range_new(R(B),R(B+1),C) */
      int b = 7;
      regs[7] = mrb_range_new(mrb, regs[b], regs[b+1], 0);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 0, 1]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_11:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 6, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_12:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[6];
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_13:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 4, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_14:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_15:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 9, 5, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_16:
  {
      /* A B    R(A) := R(B) */
      regs[9] = regs[5];
      NEXT;
    }

  // ["OP_ARRAY", 7, 7, 3]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_17:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[7] = mrb_ary_new_from_values(mrb, 3, &regs[7]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 8, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_18:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[8] = mrb_str_new_cstr(mrb, "");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 7, 3, 1]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_19:
  {
      int a = 7;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "join"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 2, 1]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_20:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "replace"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 6, 0, 0]
  L_MET_7EDA5C36F56FDD4A6DAA4014EF3540A9_21:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[6];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_aa8e240f42d5be51c6fb1a70277db68b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_2:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "bytes"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 4, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_3:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[4];
      NEXT;
    }

  // ["OP_LOADI", 3, 255, 127]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 8]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_5:
  goto L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_14;
  // ["OP_MOVE", 4, 1, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_7:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_8:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 1]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_9:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 4, 1, 1]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_11:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 4, 3, 1]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_12:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 4;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_13:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_14:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_15:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 5, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_16:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LT", 4, 4, 1]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_17:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 4, 255, 115]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_18:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_6;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_19:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_AA8E240F42D5BE51C6FB1A70277DB68B_20:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f0058f9c767982ac633a89df55ee0495(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_F0058F9C767982AC633A89DF55EE0495_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F0058F9C767982AC633A89DF55EE0495_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F0058F9C767982AC633A89DF55EE0495_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_F0058F9C767982AC633A89DF55EE0495_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 8]
  L_MET_F0058F9C767982AC633A89DF55EE0495_2:
  goto L_MET_F0058F9C767982AC633A89DF55EE0495_11;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_3:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_4:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_F0058F9C767982AC633A89DF55EE0495_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_F0058F9C767982AC633A89DF55EE0495_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_ADDI", 3, 2, 1]
  L_MET_F0058F9C767982AC633A89DF55EE0495_9:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_10:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_11:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_12:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_13:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LT", 3, 3, 1]
  L_MET_F0058F9C767982AC633A89DF55EE0495_14:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 3, 255, 115]
  L_MET_F0058F9C767982AC633A89DF55EE0495_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_F0058F9C767982AC633A89DF55EE0495_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_16:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_F0058F9C767982AC633A89DF55EE0495_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_e369bba98299629dad3110f27511c3b8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_E369BBA98299629DAD3110F27511C3B8_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_E369BBA98299629DAD3110F27511C3B8_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_E369BBA98299629DAD3110F27511C3B8_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 5, 5, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_2:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[5] = mrb_ary_new_from_values(mrb, 0, &regs[5]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_3:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 5, 6, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_4:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[5],
                     mrb_ary_splat(mrb, regs[6]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_5:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 127]
  L_MET_E369BBA98299629DAD3110F27511C3B8_6:
  {
      int a = 4;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "sub"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_7:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_8:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_9:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_E369BBA98299629DAD3110F27511C3B8_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 5]
  L_MET_E369BBA98299629DAD3110F27511C3B8_11:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_E369BBA98299629DAD3110F27511C3B8_17;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_12:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_13:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_E369BBA98299629DAD3110F27511C3B8_14:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "replace"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_15:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_E369BBA98299629DAD3110F27511C3B8_16:
  goto L_MET_E369BBA98299629DAD3110F27511C3B8_18;
  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_17:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_E369BBA98299629DAD3110F27511C3B8_18:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_679e32825c669c43179b36b7ac5bc8d2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_679E32825C669C43179B36B7AC5BC8D2_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_679E32825C669C43179B36B7AC5BC8D2_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_2:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 256, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 1);
      NEXT;
    }

  // ["OP_EQ", 3, 1, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_4:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_679E32825C669C43179B36B7AC5BC8D2_7;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_JMPIF", 3, 256, 4]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_679E32825C669C43179B36B7AC5BC8D2_12;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_9:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 256, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_10:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 2);
      NEXT;
    }

  // ["OP_EQ", 3, 1, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_679E32825C669C43179B36B7AC5BC8D2_14;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_13:
  goto L_MET_679E32825C669C43179B36B7AC5BC8D2_18;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_14:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 3]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_15:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "ArgumentError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_16:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "wrong number of arguments");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 2, 2]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_17:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 3, 0, 4]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_18:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 4, 0, 6]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_19:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[4], mrb_intern(mrb, "Regexp"));
      NEXT;
    }

  // ["OP_SEND", 3, 5, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_20:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_21:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_679E32825C669C43179B36B7AC5BC8D2_23;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_22:
  goto L_MET_679E32825C669C43179B36B7AC5BC8D2_27;
  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_23:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 7]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_24:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 4, 0, 1]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_25:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "sub not available (yet)");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 2, 2]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_26:
  {
      int a = 2;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_679E32825C669C43179B36B7AC5BC8D2_27:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_aff10df0265b0693b91d69f2ced85711(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_AFF10DF0265B0693B91D69F2CED85711_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_AFF10DF0265B0693B91D69F2CED85711_1;
      }
      
    }

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 4, 0, 2]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_2:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[4], mrb_intern(mrb, "Regexp"));
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_AFF10DF0265B0693B91D69F2CED85711_6;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_5:
  goto L_MET_AFF10DF0265B0693B91D69F2CED85711_10;
  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_6:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 4]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_7:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 4, 0, 0]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_8:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "scan not available (yet)");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 3, 2]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_9:
  {
      int a = 2;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_AFF10DF0265B0693B91D69F2CED85711_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_9e0ed5c2fa5d5202e26a1eab356ec6f2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 5, 5, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_2:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[5] = mrb_ary_new_from_values(mrb, 0, &regs[5]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_3:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 5, 6, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_4:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[5],
                     mrb_ary_splat(mrb, regs[6]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_5:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 127]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_6:
  {
      int a = 4;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "gsub"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_7:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_8:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_9:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 5]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_11:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_17;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_12:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_13:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_14:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "replace"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_15:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_16:
  goto L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_18;
  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_17:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_9E0ED5C2FA5D5202E26A1EAB356EC6F2_18:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_807df189bea44c56e24b7a82b0e755c8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_2:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 256, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 1);
      NEXT;
    }

  // ["OP_EQ", 3, 1, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_4:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_7;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_JMPIF", 3, 256, 4]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_12;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_9:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 256, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_10:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 2);
      NEXT;
    }

  // ["OP_EQ", 3, 1, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_14;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_13:
  goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_18;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_14:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 3]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_15:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "ArgumentError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_16:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "wrong number of arguments");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 2, 2]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_17:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 3, 0, 4]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_18:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 4, 0, 6]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_19:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[4], mrb_intern(mrb, "Regexp"));
      NEXT;
    }

  // ["OP_SEND", 3, 5, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_20:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_21:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_23;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_22:
  goto L_MET_807DF189BEA44C56E24B7A82B0E755C8_27;
  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_23:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 3, 0, 7]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_24:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 4, 0, 1]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_25:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "gsub not available (yet)");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 2, 2, 2]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_26:
  {
      int a = 2;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_807DF189BEA44C56E24B7A82B0E755C8_27:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3d8cab6941a3224e383ab4e06467defa(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (9 < 3) ? 3 : 9, 3);
  }
  else {
    stack_extend(mrb, 9, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 9 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_3D8CAB6941A3224E383AB4E06467DEFA_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_3D8CAB6941A3224E383AB4E06467DEFA_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 12]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_2:
  goto L_MET_3D8CAB6941A3224E383AB4E06467DEFA_15;
  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_4:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_5:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 7, 3, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_6:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 7, 2, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_7:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 7;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_8:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_SUB", 7, 3, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_9:
  {
      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/
      int a = 7;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x - y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x - y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(-,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(-,attr_f,attr_f);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SEND", 5, 1, 2]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_10:
  {
      int a = 5;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 4, 0, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_11:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 4, 2, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_13:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 4;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 4, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_14:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[4];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_15:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LOADI", 5, 256, 9]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_16:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 10);
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_17:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 2]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_18:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "index"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_19:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_JMPIF", 4, 255, 110]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_20:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_3D8CAB6941A3224E383AB4E06467DEFA_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_21:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 5, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_22:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_23:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_GT", 4, 6, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_24:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 9]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_25:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_3D8CAB6941A3224E383AB4E06467DEFA_35;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_26:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_27:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_28:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 7, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_29:
  {
      /* A      R(A) := self */
      regs[7] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 7, 5, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_30:
  {
      int a = 7;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_31:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_SUB", 7, 3, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_32:
  {
      /* A B C  R(A) := R(A)-R(A+1) (Syms[B]=:-,C=1)*/
      int a = 7;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x - y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x - y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(-,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(-,attr_f,attr_f);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SEND", 5, 1, 2]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_33:
  {
      int a = 5;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 4, 0, 1]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_34:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_35:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_3D8CAB6941A3224E383AB4E06467DEFA_36:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c553f446c939911bcdb59bff0006d798(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_C553F446C939911BCDB59BFF0006D798_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3d8cab6941a3224e383ab4e06467defa, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_3d8cab6941a3224e383ab4e06467defa);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_line"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_C553F446C939911BCDB59BFF0006D798_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_807df189bea44c56e24b7a82b0e755c8, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_807df189bea44c56e24b7a82b0e755c8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "gsub"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_C553F446C939911BCDB59BFF0006D798_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_9e0ed5c2fa5d5202e26a1eab356ec6f2, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_9e0ed5c2fa5d5202e26a1eab356ec6f2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "gsub!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_C553F446C939911BCDB59BFF0006D798_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_aff10df0265b0693b91d69f2ced85711, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_aff10df0265b0693b91d69f2ced85711);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "scan"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_12:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 21]
  L_MET_C553F446C939911BCDB59BFF0006D798_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_679e32825c669c43179b36b7ac5bc8d2, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_679e32825c669c43179b36b7ac5bc8d2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_14:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "sub"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_15:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 25]
  L_MET_C553F446C939911BCDB59BFF0006D798_16:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_e369bba98299629dad3110f27511c3b8, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_e369bba98299629dad3110f27511c3b8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_17:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "sub!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_18:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 29]
  L_MET_C553F446C939911BCDB59BFF0006D798_19:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f0058f9c767982ac633a89df55ee0495, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f0058f9c767982ac633a89df55ee0495);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 6, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_20:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_char"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_21:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 33]
  L_MET_C553F446C939911BCDB59BFF0006D798_22:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_aa8e240f42d5be51c6fb1a70277db68b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_aa8e240f42d5be51c6fb1a70277db68b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 7, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_23:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_byte"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_24:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 37]
  L_MET_C553F446C939911BCDB59BFF0006D798_25:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_7eda5c36f56fdd4a6daa4014ef3540a9, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_7eda5c36f56fdd4a6daa4014ef3540a9);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 8, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_26:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "[]="), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_27:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_C553F446C939911BCDB59BFF0006D798_28:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_be61fdad296d276710c528c5f12d9067(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_BE61FDAD296D276710C528C5F12D9067_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_BE61FDAD296D276710C528C5F12D9067_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Enumerable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_BE61FDAD296D276710C528C5F12D9067_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_BE61FDAD296D276710C528C5F12D9067_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c38d302a7f3f4d0b7cb2b60b1a27c8ae(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_C38D302A7F3F4D0B7CB2B60B1A27C8AE_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_C38D302A7F3F4D0B7CB2B60B1A27C8AE_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_9e17e98a646b06c2cce1985e9210bd9d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_2:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "first"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 4, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_3:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_LOADSYM", 5, 0, 2]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_5:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[5], mrb_intern(mrb, "succ"));
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "respond_to?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_9;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_8:
  goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_13;
  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_9:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 5, 0, 4]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_10:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[5] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TypeError"));
      NEXT;
    }

  // ["OP_STRING", 6, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_11:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "can't iterate");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 3, 2]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_12:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_13:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 5, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_14:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "last"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_15:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_16:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_17:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 6, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_18:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_19:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_GT", 4, 7, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_20:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_21:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_24;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_22:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_23:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_24:
  goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_31;
  // ["OP_MOVE", 5, 1, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_25:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_26:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 8, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_27:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_28:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_29:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "succ"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 2, 5, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_30:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_31:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_32:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 5, 6, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_33:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 6, 255, 127]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_34:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 0);
      NEXT;
    }

  // ["OP_LT", 5, 9, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_35:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 116]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_36:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_25;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_37:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 5, 10, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_38:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "exclude_end?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_39:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_41;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_40:
  goto L_MET_9E17E98A646B06C2CCE1985E9210BD9D_44;
  // ["OP_MOVE", 5, 1, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_41:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_42:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 8, 1]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_43:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_44:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_9E17E98A646B06C2CCE1985E9210BD9D_45:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4727db1f3bad8f9c2851d61e88442727(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_4727DB1F3BAD8F9C2851D61E88442727_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_4727DB1F3BAD8F9C2851D61E88442727_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_9e17e98a646b06c2cce1985e9210bd9d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_9e17e98a646b06c2cce1985e9210bd9d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_4727DB1F3BAD8F9C2851D61E88442727_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_4727DB1F3BAD8F9C2851D61E88442727_3:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_4727DB1F3BAD8F9C2851D61E88442727_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_78248b95c3404d421423a5f734cd507e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_78248B95C3404D421423A5F734CD507E_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_78248B95C3404D421423A5F734CD507E_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_78248B95C3404D421423A5F734CD507E_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_78248B95C3404D421423A5F734CD507E_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_78248B95C3404D421423A5F734CD507E_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_78248B95C3404D421423A5F734CD507E_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "printf not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_78248B95C3404D421423A5F734CD507E_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_78248B95C3404D421423A5F734CD507E_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_78248B95C3404D421423A5F734CD507E_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a909849ee38bc0f9e80132f37655ab93(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_A909849EE38BC0F9E80132F37655AB93_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_A909849EE38BC0F9E80132F37655AB93_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_A909849EE38BC0F9E80132F37655AB93_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_A909849EE38BC0F9E80132F37655AB93_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_A909849EE38BC0F9E80132F37655AB93_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_A909849EE38BC0F9E80132F37655AB93_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "p not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_A909849EE38BC0F9E80132F37655AB93_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_A909849EE38BC0F9E80132F37655AB93_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_A909849EE38BC0F9E80132F37655AB93_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dbdba7107bb9f593fb85870bc0a8494a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DBDBA7107BB9F593FB85870BC0A8494A_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DBDBA7107BB9F593FB85870BC0A8494A_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "puts not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_DBDBA7107BB9F593FB85870BC0A8494A_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_533aa371fd4c3a44806ea1421f2f4f95(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_533AA371FD4C3A44806EA1421F2F4F95_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_533AA371FD4C3A44806EA1421F2F4F95_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "print not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_533AA371FD4C3A44806EA1421F2F4F95_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_8004132f122b7968a5dbd36ecfcf1ffa(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_8004132F122B7968A5DBD36ECFCF1FFA_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_8004132F122B7968A5DBD36ECFCF1FFA_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 5, 5, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_3:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[5] = mrb_ary_new_from_values(mrb, 0, &regs[5]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_4:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 5, 6, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_5:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[5],
                     mrb_ary_splat(mrb, regs[6]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 1, 127]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_6:
  {
      int a = 4;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "sprintf"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_8:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_8004132F122B7968A5DBD36ECFCF1FFA_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d6f8e6f52c798cf8fe3f331fd7ebc4b3(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_1;
      }
      
    }

  // ["OP_LOADI", 3, 255, 127]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 0);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 0, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_3:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 12]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_5:
  goto L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_18;
  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_6:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 7, 3, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_8:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 6, 2, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_9:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 3, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_10:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "inspect"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 5, 1, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_11:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_12:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 6, 0, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_13:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[6] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 1, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_14:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_15:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 5, 4, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_16:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 5, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_17:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_18:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_19:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_LT", 5, 5, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_20:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 112]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_21:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_6;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_22:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 6, 255, 127]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_23:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 0);
      NEXT;
    }

  // ["OP_SEND", 5, 2, 1]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_24:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 5, 0, 0]
  L_MET_D6F8E6F52C798CF8FE3F331FD7EBC4B3_25:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[5];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d28dc1fd50a8091e7fc7f28be895c6a9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_1;
      }
      
    }

  // ["OP_LOADI", 3, 255, 127]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 0);
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_2:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_3:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 6, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[6];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 20]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_5:
  goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_26;
  // ["OP_MOVE", 6, 1, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_6:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 7, 3, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_7:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 6, 1, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_8:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 2, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_9:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 6, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[6];
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_11:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 5, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_12:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[5];
      NEXT;
    }

  // ["OP_SEND", 6, 3, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_13:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 6, 5, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_14:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[5];
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 126]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_15:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], -1);
      NEXT;
    }

  // ["OP_SEND", 6, 1, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_16:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 7, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_17:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 4, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_18:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 6, 256, 3]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_19:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_23;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_20:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 7, 0, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_21:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 3, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_22:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_23:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 6, 5, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_24:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 6;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 6, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_25:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[6];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_26:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 7, 4, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_27:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[4];
      NEXT;
    }

  // ["OP_LT", 6, 6, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_28:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 6; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 6, 255, 104]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_29:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[6])) {
        goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_6;
      }
      NEXT;
    }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_30:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 127]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_31:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 0);
      NEXT;
    }

  // ["OP_EQ", 6, 7, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_32:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 6;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 6; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 6, 256, 3]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_33:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_37;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_34:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 7, 0, 2]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_35:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "\n");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 3, 1]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_36:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_37:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D28DC1FD50A8091E7FC7F28BE895C6A9_38:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0d325e96579ca701ffaef541c4048881(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0D325E96579CA701FFAEF541C4048881_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0D325E96579CA701FFAEF541C4048881_1;
      }
      
    }

  // ["OP_LOADI", 3, 255, 127]
  L_MET_0D325E96579CA701FFAEF541C4048881_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[3], 0);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 0, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_3:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 9]
  L_MET_0D325E96579CA701FFAEF541C4048881_5:
  goto L_MET_0D325E96579CA701FFAEF541C4048881_15;
  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_6:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 7, 3, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_8:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 6, 2, 1]
  L_MET_0D325E96579CA701FFAEF541C4048881_9:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 3, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_10:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 5, 1, 1]
  L_MET_0D325E96579CA701FFAEF541C4048881_11:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__printstr__"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_12:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 5, 4, 1]
  L_MET_0D325E96579CA701FFAEF541C4048881_13:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 5, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_14:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_15:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_16:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_LT", 5, 5, 1]
  L_MET_0D325E96579CA701FFAEF541C4048881_17:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 115]
  L_MET_0D325E96579CA701FFAEF541C4048881_18:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_0D325E96579CA701FFAEF541C4048881_6;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_19:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_0D325E96579CA701FFAEF541C4048881_20:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c1d65bde78ea67ee6da3fcd9c1af9016(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "sprintf not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_C1D65BDE78EA67EE6DA3FCD9C1AF9016_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_09ed7468cd985a7c0d4eb008bfde5f13(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "printf not available");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_09ED7468CD985A7C0D4EB008BFDE5F13_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_aabcef40440421089b94608388c7200a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_0:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Kernel"));
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 2]
  L_MET_AABCEF40440421089B94608388C7200A_1:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "__printstr__"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_AABCEF40440421089B94608388C7200A_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "respond_to?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 25]
  L_MET_AABCEF40440421089B94608388C7200A_3:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_AABCEF40440421089B94608388C7200A_29;
      }
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_4:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Kernel"));
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 3]
  L_MET_AABCEF40440421089B94608388C7200A_5:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "sprintf"));
      NEXT;
    }

  // ["OP_SEND", 1, 1, 1]
  L_MET_AABCEF40440421089B94608388C7200A_6:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "respond_to?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 1]
  L_MET_AABCEF40440421089B94608388C7200A_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_MET_AABCEF40440421089B94608388C7200A_9;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_AABCEF40440421089B94608388C7200A_8:
  goto L_MET_AABCEF40440421089B94608388C7200A_15;
  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_AABCEF40440421089B94608388C7200A_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_09ed7468cd985a7c0d4eb008bfde5f13, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_09ed7468cd985a7c0d4eb008bfde5f13);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_AABCEF40440421089B94608388C7200A_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "printf"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_12:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_AABCEF40440421089B94608388C7200A_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_c1d65bde78ea67ee6da3fcd9c1af9016, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_c1d65bde78ea67ee6da3fcd9c1af9016);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_AABCEF40440421089B94608388C7200A_14:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "sprintf"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_15:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_AABCEF40440421089B94608388C7200A_16:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0d325e96579ca701ffaef541c4048881, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0d325e96579ca701ffaef541c4048881);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_AABCEF40440421089B94608388C7200A_17:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "print"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_18:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_AABCEF40440421089B94608388C7200A_19:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d28dc1fd50a8091e7fc7f28be895c6a9, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d28dc1fd50a8091e7fc7f28be895c6a9);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 6, 0]
  L_MET_AABCEF40440421089B94608388C7200A_20:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "puts"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_21:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 21]
  L_MET_AABCEF40440421089B94608388C7200A_22:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d6f8e6f52c798cf8fe3f331fd7ebc4b3, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d6f8e6f52c798cf8fe3f331fd7ebc4b3);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 7, 0]
  L_MET_AABCEF40440421089B94608388C7200A_23:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "p"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_24:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 25]
  L_MET_AABCEF40440421089B94608388C7200A_25:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_8004132f122b7968a5dbd36ecfcf1ffa, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_8004132f122b7968a5dbd36ecfcf1ffa);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_AABCEF40440421089B94608388C7200A_26:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "printf"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_27:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 13]
  L_MET_AABCEF40440421089B94608388C7200A_28:
  goto L_MET_AABCEF40440421089B94608388C7200A_42;
  // ["OP_TCLASS", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_29:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[0] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 1, 0, 29]
  L_MET_AABCEF40440421089B94608388C7200A_30:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_533aa371fd4c3a44806ea1421f2f4f95, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_533aa371fd4c3a44806ea1421f2f4f95);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[1] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 0, 5, 0]
  L_MET_AABCEF40440421089B94608388C7200A_31:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 0;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "print"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_32:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[0] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 1, 0, 33]
  L_MET_AABCEF40440421089B94608388C7200A_33:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dbdba7107bb9f593fb85870bc0a8494a, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_dbdba7107bb9f593fb85870bc0a8494a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[1] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 0, 6, 0]
  L_MET_AABCEF40440421089B94608388C7200A_34:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 0;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "puts"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_35:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[0] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 1, 0, 37]
  L_MET_AABCEF40440421089B94608388C7200A_36:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a909849ee38bc0f9e80132f37655ab93, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a909849ee38bc0f9e80132f37655ab93);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[1] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 0, 7, 0]
  L_MET_AABCEF40440421089B94608388C7200A_37:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 0;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "p"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_38:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[0] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 1, 0, 41]
  L_MET_AABCEF40440421089B94608388C7200A_39:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_78248b95c3404d421423a5f734cd507e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_78248b95c3404d421423a5f734cd507e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[1] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 0, 4, 0]
  L_MET_AABCEF40440421089B94608388C7200A_40:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 0;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "printf"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_41:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_AABCEF40440421089B94608388C7200A_42:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ab4246b29884a51a89ba8be8a5382f41(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_AB4246B29884A51A89BA8BE8A5382F41_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_AB4246B29884A51A89BA8BE8A5382F41_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Comparable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_AB4246B29884A51A89BA8BE8A5382F41_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_AB4246B29884A51A89BA8BE8A5382F41_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d7cd309660f17ad68edc8d5f2e23c79a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D7CD309660F17AD68EDC8D5F2E23C79A_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D7CD309660F17AD68EDC8D5F2E23C79A_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_095b4e5b648599eb3b598a59d2cf52ca(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 64, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 270337;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
  
    switch(argc) {
  case 1: goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_1;
}

      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_2;
      }
      
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_1:
  goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_3;
  // ["OP_JMP", 0, 256, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_2:
  goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_4;
  // ["OP_LOADI", 2, 256, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_4:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_GETCONST", 6, 0, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_5:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Float"));
      NEXT;
    }

  // ["OP_SEND", 5, 0, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_6:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "kind_of?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 3]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_11;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_8:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_9:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_f"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_10:
  goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_12;
  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_11:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 7]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_13:
  goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_21;
  // ["OP_MOVE", 5, 3, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_14:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_15:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 5, 3, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_16:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 4, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_17:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_18:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_ADD", 5, 4, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_19:
  {
      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/
      int a = 5;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x + y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x + y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(+,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(+,attr_f,attr_f);
  break;
      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
  regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_20:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 4, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_21:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_22:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_LE", 5, 5, 1]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_23:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<=);
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 117]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_24:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_095B4E5B648599EB3B598A59D2CF52CA_14;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_25:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_095B4E5B648599EB3B598A59D2CF52CA_26:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_e0a5388aea7231fdc5a704bad957d191(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_E0A5388AEA7231FDC5A704BAD957D191_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_E0A5388AEA7231FDC5A704BAD957D191_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_2:
  goto L_MET_E0A5388AEA7231FDC5A704BAD957D191_9;
  // ["OP_MOVE", 4, 2, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_4:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_5:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 4, 1, 1]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_7:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 4;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_9:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LE", 4, 2, 1]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(<=);
      NEXT;
    }

  // ["OP_JMPIF", 4, 255, 118]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_E0A5388AEA7231FDC5A704BAD957D191_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_13:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_E0A5388AEA7231FDC5A704BAD957D191_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5d7a7655e88cb0ad60d8eef2d642e191(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_2:
  goto L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_9;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_3:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_ADDI", 3, 1, 1]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_7:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_8:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_9:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_10:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LT", 3, 2, 1]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 3, 255, 118]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_13:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_5D7A7655E88CB0AD60D8EEF2D642E191_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_89d7e3d8c694b5c5eb3c6552a68f04f1(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_2:
  goto L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_9;
  // ["OP_MOVE", 4, 2, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_4:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_5:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_SUBI", 4, 1, 1]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_7:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 4;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_9:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_GE", 4, 2, 1]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_11:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>=);
      NEXT;
    }

  // ["OP_JMPIF", 4, 255, 118]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_12:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_13:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_89D7E3D8C694B5C5EB3C6552A68F04F1_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c09e2f97a0ceaf65200b58cdc9ef38f5(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_89d7e3d8c694b5c5eb3c6552a68f04f1, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_89d7e3d8c694b5c5eb3c6552a68f04f1);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "downto"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5d7a7655e88cb0ad60d8eef2d642e191, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_5d7a7655e88cb0ad60d8eef2d642e191);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "times"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_e0a5388aea7231fdc5a704bad957d191, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_e0a5388aea7231fdc5a704bad957d191);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "upto"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_095b4e5b648599eb3b598a59d2cf52ca, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_095b4e5b648599eb3b598a59d2cf52ca);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "step"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_12:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_C09E2F97A0CEAF65200B58CDC9EF38F5_13:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_6c50412718b19b8204bea1b7312ed6f8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_6C50412718B19B8204BEA1B7312ED6F8_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_6C50412718B19B8204BEA1B7312ED6F8_1;
      }
      
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_1:
  goto L_MET_6C50412718B19B8204BEA1B7312ED6F8_4;
  // ["OP_BLKPUSH", 2, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_2:
  {
      /* A Bx   R(A) := block (16=6:1:5:4) */
      int a = 2;
      int bx = 0;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
  if (!e) {
    localjump_error(mrb, "yield");
    mrbb_raise(mrb, prev_jmp);
  }
        stack = e->stack + 1;
      }
      regs[a] = stack[m1+r+m2];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_3:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_4:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_JMPIF", 2, 255, 124]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[2])) {
        goto L_MET_6C50412718B19B8204BEA1B7312ED6F8_2;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_6:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_6C50412718B19B8204BEA1B7312ED6F8_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2edafd1d7a1729345879eff070c5b784(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_2EDAFD1D7A1729345879EFF070C5B784_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_2EDAFD1D7A1729345879EFF070C5B784_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_2EDAFD1D7A1729345879EFF070C5B784_1;
      }
      
    }

  // ["OP_GETCONST", 3, 0, 0]
  L_MET_2EDAFD1D7A1729345879EFF070C5B784_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[3] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Kernel"));
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_2EDAFD1D7A1729345879EFF070C5B784_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_2EDAFD1D7A1729345879EFF070C5B784_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "eval"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_2EDAFD1D7A1729345879EFF070C5B784_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d45d86eecd32130537a878702ac80a6f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_D45D86EECD32130537A878702AC80A6F_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D45D86EECD32130537A878702AC80A6F_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D45D86EECD32130537A878702AC80A6F_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_D45D86EECD32130537A878702AC80A6F_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 4, 0, 1]
  L_MET_D45D86EECD32130537A878702AC80A6F_2:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[4] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NotImplementedError"));
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_D45D86EECD32130537A878702AC80A6F_3:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "eval not implemented");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_D45D86EECD32130537A878702AC80A6F_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_D45D86EECD32130537A878702AC80A6F_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_D45D86EECD32130537A878702AC80A6F_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d14bd5220a2cd54fcd1a96e567a0217d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D14BD5220A2CD54FCD1A96E567A0217D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D14BD5220A2CD54FCD1A96E567A0217D_1;
      }
      
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_1:
  goto L_MET_D14BD5220A2CD54FCD1A96E567A0217D_4;
  // ["OP_BLKPUSH", 2, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_2:
  {
      /* A Bx   R(A) := block (16=6:1:5:4) */
      int a = 2;
      int bx = 0;
      int m1 = (bx>>10)&0x3f;
      int r  = (bx>>9)&0x1;
      int m2 = (bx>>4)&0x1f;
      int lv = (bx>>0)&0xf;
      mrb_value *stack;

      if (lv == 0) stack = regs + 1;
      else {
        struct REnv *e = uvenv(mrb, lv-1);
  if (!e) {
    localjump_error(mrb, "yield");
    mrbb_raise(mrb, prev_jmp);
  }
        stack = e->stack + 1;
      }
      regs[a] = stack[m1+r+m2];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_3:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_4:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_JMPIF", 2, 255, 124]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[2])) {
        goto L_MET_D14BD5220A2CD54FCD1A96E567A0217D_2;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_6:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D14BD5220A2CD54FCD1A96E567A0217D_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_41556fda4224ba58910dbd8d37c2c174(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_SCLASS", 1, 1, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_1:
  {
      /* A B    R(A) := R(B).singleton_class */
      regs[1] = mrb_singleton_class(mrb, regs[1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_2:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d14bd5220a2cd54fcd1a96e567a0217d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d14bd5220a2cd54fcd1a96e567a0217d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_3:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "loop"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_4:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_SCLASS", 1, 1, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_5:
  {
      /* A B    R(A) := R(B).singleton_class */
      regs[1] = mrb_singleton_class(mrb, regs[1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_6:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d45d86eecd32130537a878702ac80a6f, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d45d86eecd32130537a878702ac80a6f);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_7:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "eval"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_8:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_9:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2edafd1d7a1729345879eff070c5b784, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_2edafd1d7a1729345879eff070c5b784);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_10:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "eval"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_11:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_12:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_6c50412718b19b8204bea1b7312ed6f8, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_6c50412718b19b8204bea1b7312ed6f8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_13:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "loop"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_14:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_41556FDA4224BA58910DBD8D37C2C174_15:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4b50dff2bf09778333229dc93623fe20(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_4B50DFF2BF09778333229DC93623FE20_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_4B50DFF2BF09778333229DC93623FE20_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Enumerable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_4B50DFF2BF09778333229DC93623FE20_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_4B50DFF2BF09778333229DC93623FE20_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d32b189f6d0c9da345245f2bc7305b1b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D32B189F6D0C9DA345245F2BC7305B1B_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D32B189F6D0C9DA345245F2BC7305B1B_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b780e9abca207d4d66cb51efce0a61cd(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_8:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 6]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_16;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 2, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_11:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_12:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 7, 4, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_13:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 2]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_14:
  {
      int a = 5;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_15:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_B780E9ABCA207D4D66CB51EFCE0A61CD_16:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2636b064aa202b3386ce6cbf7b7fa8be(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_1;
      }
      
    }

  // ["OP_HASH", 2, 3, 0]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_1:
  {
      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */
      int b = 3;
      int c = 0;
      int lim = b+c*2;
      mrb_value hash = mrb_hash_new_capa(mrb, c);

      while (b < lim) {
        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);
        b+=2;
      }
      regs[2] = hash;
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b780e9abca207d4d66cb51efce0a61cd, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_b780e9abca207d4d66cb51efce0a61cd);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_2636B064AA202B3386CE6CBF7B7FA8BE_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ee7897d6e377bd57384de57c11de90be(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_EE7897D6E377BD57384DE57C11DE90BE_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_EE7897D6E377BD57384DE57C11DE90BE_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_EE7897D6E377BD57384DE57C11DE90BE_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_EE7897D6E377BD57384DE57C11DE90BE_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_EE7897D6E377BD57384DE57C11DE90BE_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_EE7897D6E377BD57384DE57C11DE90BE_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "delete"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_EE7897D6E377BD57384DE57C11DE90BE_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dda91b314e193e2c0651697bdf20968d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DDA91B314E193E2C0651697BDF20968D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DDA91B314E193E2C0651697BDF20968D_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_DDA91B314E193E2C0651697BDF20968D_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_DDA91B314E193E2C0651697BDF20968D_8:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 1]
  L_MET_DDA91B314E193E2C0651697BDF20968D_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_DDA91B314E193E2C0651697BDF20968D_11;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_DDA91B314E193E2C0651697BDF20968D_10:
  goto L_MET_DDA91B314E193E2C0651697BDF20968D_14;
  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_11:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_DDA91B314E193E2C0651697BDF20968D_13:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_DDA91B314E193E2C0651697BDF20968D_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_1a2411defb9cefdcf45fec8bf8b87407(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dda91b314e193e2c0651697bdf20968d, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_dda91b314e193e2c0651697bdf20968d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_5:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_7:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_EQ", 3, 2, 1]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_8:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 2]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_12;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_10:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 10]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ee7897d6e377bd57384de57c11de90be, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_ee7897d6e377bd57384de57c11de90be);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_14:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_15:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_1A2411DEFB9CEFDCF45FEC8BF8B87407_16:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ebbb24ae3025f1a2c41cba3775cbc6e6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_8:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 1]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_11;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 5]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_10:
  goto L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_16;
  // ["OP_MOVE", 3, 3, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_11:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[3];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 2, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_12:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_13:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_14:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 2]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_15:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_EBBB24AE3025F1A2C41CBA3775CBC6E6_16:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d7e827d30ce1ec482a28d65a12c69227(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D7E827D30CE1EC482A28D65A12C69227_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D7E827D30CE1EC482A28D65A12C69227_1;
      }
      
    }

  // ["OP_HASH", 2, 3, 0]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_1:
  {
      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */
      int b = 3;
      int c = 0;
      int lim = b+c*2;
      mrb_value hash = mrb_hash_new_capa(mrb, c);

      while (b < lim) {
        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);
        b+=2;
      }
      regs[2] = hash;
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ebbb24ae3025f1a2c41cba3775cbc6e6, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_ebbb24ae3025f1a2c41cba3775cbc6e6);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_D7E827D30CE1EC482A28D65A12C69227_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_123be4840a3165cd21095e3aca479dd7(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_123BE4840A3165CD21095E3ACA479DD7_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_123BE4840A3165CD21095E3ACA479DD7_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_123BE4840A3165CD21095E3ACA479DD7_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_123BE4840A3165CD21095E3ACA479DD7_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_123BE4840A3165CD21095E3ACA479DD7_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_123BE4840A3165CD21095E3ACA479DD7_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "delete"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_123BE4840A3165CD21095E3ACA479DD7_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_881d50fa1df6109363d749b63f3832a2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_881D50FA1DF6109363D749B63F3832A2_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_881D50FA1DF6109363D749B63F3832A2_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_881D50FA1DF6109363D749B63F3832A2_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_881D50FA1DF6109363D749B63F3832A2_8:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 4]
  L_MET_881D50FA1DF6109363D749B63F3832A2_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_881D50FA1DF6109363D749B63F3832A2_14;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 2, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_10:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_11:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_881D50FA1DF6109363D749B63F3832A2_12:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_13:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_881D50FA1DF6109363D749B63F3832A2_14:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a64c66312f3e8c2c2eb26d18adbae377(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_881d50fa1df6109363d749b63f3832a2, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_881d50fa1df6109363d749b63f3832a2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_5:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_7:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_EQ", 3, 2, 1]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_8:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 2]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_12;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_10:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 10]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_123be4840a3165cd21095e3aca479dd7, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_123be4840a3165cd21095e3aca479dd7);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_14:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_15:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_A64C66312F3E8C2C2EB26D18ADBAE377_16:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f7e501245ff438be1a3b61edbbf56346(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F7E501245FF438BE1A3B61EDBBF56346_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F7E501245FF438BE1A3B61EDBBF56346_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_4:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_6:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_7:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_F7E501245FF438BE1A3B61EDBBF56346_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f605f0c100f59e6a77a0b74a15c8adf4(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (8 < 3) ? 3 : 8, 3);
  }
  else {
    stack_extend(mrb, 8, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 8 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "has_key?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 10]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_15;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_7:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_8:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 2, 1]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_9:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 6, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_10:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[6] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_11:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 2, 1]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_12:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 1, 3]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_13:
  {
      int a = 3;
      int n = 3;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_14:
  goto L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_18;
  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_15:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_16:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_17:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_18:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_19:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_20:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 3, 2]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_21:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_F605F0C100F59E6A77A0B74A15C8ADF4_22:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_36100cc5debae676336d3bf212142fbf(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_36100CC5DEBAE676336D3BF212142FBF_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_36100CC5DEBAE676336D3BF212142FBF_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_4:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_6:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 2]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_7:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_36100CC5DEBAE676336D3BF212142FBF_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3d30aafa79b44d303aa106862da34d79(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_3D30AAFA79B44D303AA106862DA34D79_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_3D30AAFA79B44D303AA106862DA34D79_1;
      }
      
    }

  // ["OP_HASH", 3, 4, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_1:
  {
      /* A B C   R(A) := hash_new(R(B),R(B+1)..R(B+C)) */
      int b = 4;
      int c = 0;
      int lim = b+c*2;
      mrb_value hash = mrb_hash_new_capa(mrb, c);

      while (b < lim) {
        mrb_hash_set(mrb, hash, regs[b], regs[b+1]);
        b+=2;
      }
      regs[3] = hash;
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSYM", 5, 0, 1]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_3:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[5], mrb_intern(mrb, "to_hash"));
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "respond_to?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 1]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_3D30AAFA79B44D303AA106862DA34D79_7;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_6:
  goto L_MET_3D30AAFA79B44D303AA106862DA34D79_10;
  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_7:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 5, 0, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_8:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "can't convert argument into Hash");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_9:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_11:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_hash"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 4, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_12:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[4];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_13:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_14:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_36100cc5debae676336d3bf212142fbf, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_36100cc5debae676336d3bf212142fbf);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_15:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_16:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 4]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_17:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_3D30AAFA79B44D303AA106862DA34D79_22;
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_18:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 10]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_19:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f605f0c100f59e6a77a0b74a15c8adf4, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_f605f0c100f59e6a77a0b74a15c8adf4);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_20:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_21:
  goto L_MET_3D30AAFA79B44D303AA106862DA34D79_25;
  // ["OP_MOVE", 4, 1, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_22:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 14]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_23:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f7e501245ff438be1a3b61edbbf56346, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_f7e501245ff438be1a3b61edbbf56346);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_24:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_key"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_3D30AAFA79B44D303AA106862DA34D79_25:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_95b302cab8fef4d312d0f0558b4bc903(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_95B302CAB8FEF4D312D0F0558B4BC903_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_95B302CAB8FEF4D312D0F0558B4BC903_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_ARRAY", 4, 4, 1]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_3:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 1, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_4:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 4, 5, 0]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_5:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[4],
                     mrb_ary_splat(mrb, regs[5]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 0, 127]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_6:
  {
      int a = 3;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__init_core"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_95B302CAB8FEF4D312D0F0558B4BC903_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ac37473f6a01bd072b5e65c8e0d90bc6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_AC37473F6A01BD072B5E65C8E0D90BC6_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0db88f417b59690836e72f5d0aa52361(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_0DB88F417B59690836E72F5D0AA52361_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0DB88F417B59690836E72F5D0AA52361_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0DB88F417B59690836E72F5D0AA52361_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_0DB88F417B59690836E72F5D0AA52361_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_0DB88F417B59690836E72F5D0AA52361_2:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "keys"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_0DB88F417B59690836E72F5D0AA52361_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ac37473f6a01bd072b5e65c8e0d90bc6, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_ac37473f6a01bd072b5e65c8e0d90bc6);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 1, 0]
  L_MET_0DB88F417B59690836E72F5D0AA52361_4:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_0DB88F417B59690836E72F5D0AA52361_5:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_0DB88F417B59690836E72F5D0AA52361_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_e5e6faa1be37a1423b3ab779b5c6607c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_E5E6FAA1BE37A1423B3AB779B5C6607C_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4821e96205781ce259389f6dd1115587(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_4821E96205781CE259389F6DD1115587_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_4821E96205781CE259389F6DD1115587_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_4821E96205781CE259389F6DD1115587_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_4821E96205781CE259389F6DD1115587_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_4821E96205781CE259389F6DD1115587_2:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "keys"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_4821E96205781CE259389F6DD1115587_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_e5e6faa1be37a1423b3ab779b5c6607c, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_e5e6faa1be37a1423b3ab779b5c6607c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 1, 0]
  L_MET_4821E96205781CE259389F6DD1115587_4:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_4821E96205781CE259389F6DD1115587_5:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_4821E96205781CE259389F6DD1115587_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4967bea61fc5027e22b226e128c1bc0c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_4967BEA61FC5027E22B226E128C1BC0C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_4967BEA61FC5027E22B226E128C1BC0C_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_3:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_4:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 1, 1]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_5:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_ARRAY", 4, 4, 2]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_6:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 2, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_4967BEA61FC5027E22B226E128C1BC0C_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_468455f4493c2cbc4893542a7f38d3e9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_468455F4493C2CBC4893542A7F38D3E9_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_468455F4493C2CBC4893542A7F38D3E9_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 2, 0, 0]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_2:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "keys"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4967bea61fc5027e22b226e128c1bc0c, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_4967bea61fc5027e22b226e128c1bc0c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 1, 0]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_4:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_5:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_468455F4493C2CBC4893542A7F38D3E9_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_536e14946f1595b10b742862ab80dccb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_536E14946F1595B10B742862AB80DCCB_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_536E14946F1595B10B742862AB80DCCB_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_536E14946F1595B10B742862AB80DCCB_1;
      }
      
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_536E14946F1595B10B742862AB80DCCB_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_536E14946F1595B10B742862AB80DCCB_7;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_3:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_536E14946F1595B10B742862AB80DCCB_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "has_key?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 1, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "!"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_536E14946F1595B10B742862AB80DCCB_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_536E14946F1595B10B742862AB80DCCB_12;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_9:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_536E14946F1595B10B742862AB80DCCB_10:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_536E14946F1595B10B742862AB80DCCB_11:
  goto L_MET_536E14946F1595B10B742862AB80DCCB_15;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_12:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_13:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 3, 1]
  L_MET_536E14946F1595B10B742862AB80DCCB_14:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__delete"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_536E14946F1595B10B742862AB80DCCB_15:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_21a453610861811ef8be38c740f232a6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_21A453610861811EF8BE38C740F232A6_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_536e14946f1595b10b742862ab80dccb, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_536e14946f1595b10b742862ab80dccb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "delete"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_21A453610861811EF8BE38C740F232A6_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_468455f4493c2cbc4893542a7f38d3e9, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_468455f4493c2cbc4893542a7f38d3e9);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_21A453610861811EF8BE38C740F232A6_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4821e96205781ce259389f6dd1115587, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_4821e96205781ce259389f6dd1115587);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_key"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 25]
  L_MET_21A453610861811EF8BE38C740F232A6_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0db88f417b59690836e72f5d0aa52361, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0db88f417b59690836e72f5d0aa52361);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_value"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_12:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 33]
  L_MET_21A453610861811EF8BE38C740F232A6_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_95b302cab8fef4d312d0f0558b4bc903, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_95b302cab8fef4d312d0f0558b4bc903);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_14:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "initialize"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_15:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 37]
  L_MET_21A453610861811EF8BE38C740F232A6_16:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3d30aafa79b44d303aa106862da34d79, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_3d30aafa79b44d303aa106862da34d79);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_17:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "merge"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_18:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 53]
  L_MET_21A453610861811EF8BE38C740F232A6_19:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a64c66312f3e8c2c2eb26d18adbae377, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a64c66312f3e8c2c2eb26d18adbae377);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 6, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_20:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "reject!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_21:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 65]
  L_MET_21A453610861811EF8BE38C740F232A6_22:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d7e827d30ce1ec482a28d65a12c69227, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d7e827d30ce1ec482a28d65a12c69227);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 7, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_23:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "reject"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_24:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 73]
  L_MET_21A453610861811EF8BE38C740F232A6_25:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1a2411defb9cefdcf45fec8bf8b87407, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1a2411defb9cefdcf45fec8bf8b87407);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 8, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_26:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "select!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_27:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 85]
  L_MET_21A453610861811EF8BE38C740F232A6_28:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2636b064aa202b3386ce6cbf7b7fa8be, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_2636b064aa202b3386ce6cbf7b7fa8be);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 9, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_29:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "select"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_30:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_21A453610861811EF8BE38C740F232A6_31:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b2efba03e85432f7f3057cb06a847acb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_B2EFBA03E85432F7F3057CB06A847ACB_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_B2EFBA03E85432F7F3057CB06A847ACB_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_05db3b6057f5e307543f5a8cd6ad2089(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_05DB3B6057F5E307543F5A8CD6AD2089_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_05DB3B6057F5E307543F5A8CD6AD2089_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_36daf3be6f2106dc2720ed4049fe39ac(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_36DAF3BE6F2106DC2720ED4049FE39AC_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_36DAF3BE6F2106DC2720ED4049FE39AC_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_da5ce7e35ecc5efd33e0ed6116e5805c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_DA5CE7E35ECC5EFD33E0ED6116E5805C_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_DA5CE7E35ECC5EFD33E0ED6116E5805C_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_225cae63531646b6585dcb10e11f1ce9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_225CAE63531646B6585DCB10E11F1CE9_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_225CAE63531646B6585DCB10E11F1CE9_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_4fafa3a7fe04ebf88fcb6be967e674d8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_4FAFA3A7FE04EBF88FCB6BE967E674D8_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_4FAFA3A7FE04EBF88FCB6BE967E674D8_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_de16e07ca4abd25783aaadf78fcf769d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_DE16E07CA4ABD25783AAADF78FCF769D_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_DE16E07CA4ABD25783AAADF78FCF769D_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d70d685178cb64e87cd42b8623f38eb4(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_D70D685178CB64E87CD42B8623F38EB4_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_D70D685178CB64E87CD42B8623F38EB4_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_513d2a2f35b52951a1ac2aa83b7a824c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_513D2A2F35B52951A1AC2AA83B7A824C_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_513D2A2F35B52951A1AC2AA83B7A824C_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5ef33952ba6f987404d90f6a8e7102bf(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_5EF33952BA6F987404D90F6A8E7102BF_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_5EF33952BA6F987404D90F6A8E7102BF_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_df7c0eb9dcf5fa39497e6858264aac42(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_DF7C0EB9DCF5FA39497E6858264AAC42_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_DF7C0EB9DCF5FA39497E6858264AAC42_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_52a9608b70b06ff95ec2532087d8cdd6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_52A9608B70B06FF95EC2532087D8CDD6_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_52A9608B70B06FF95EC2532087D8CDD6_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 4, 4, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_2:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 4, 5, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_4:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[4],
                     mrb_ary_splat(mrb, regs[5]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 127]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_6:
  {
      int a = 3;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_52A9608B70B06FF95EC2532087D8CDD6_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dd6d28c90d02b371f1856e043f842f53(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_DD6D28C90D02B371F1856E043F842F53_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_SCLASS", 1, 1, 0]
  L_MET_DD6D28C90D02B371F1856E043F842F53_1:
  {
      /* A B    R(A) := R(B).singleton_class */
      regs[1] = mrb_singleton_class(mrb, regs[1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_DD6D28C90D02B371F1856E043F842F53_2:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_52a9608b70b06ff95ec2532087d8cdd6, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_52a9608b70b06ff95ec2532087d8cdd6);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_DD6D28C90D02B371F1856E043F842F53_3:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "exception"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_DD6D28C90D02B371F1856E043F842F53_4:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_DD6D28C90D02B371F1856E043F842F53_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d84ba8bfdd06429339d63795f778b504(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 8, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 524288;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D84BA8BFDD06429339D63795F778B504_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D84BA8BFDD06429339D63795F778B504_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LT", 4, 0, 1]
  L_MET_D84BA8BFDD06429339D63795F778B504_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 4, 256, 3]
  L_MET_D84BA8BFDD06429339D63795F778B504_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[4])) {
        goto L_MET_D84BA8BFDD06429339D63795F778B504_8;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_5:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_GT", 4, 1, 1]
  L_MET_D84BA8BFDD06429339D63795F778B504_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_D84BA8BFDD06429339D63795F778B504_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_D84BA8BFDD06429339D63795F778B504_11;
      }
      NEXT;
    }

  // ["OP_LOADF", 4, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_9:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_D84BA8BFDD06429339D63795F778B504_10:
  goto L_MET_D84BA8BFDD06429339D63795F778B504_12;
  // ["OP_LOADT", 4, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_11:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_D84BA8BFDD06429339D63795F778B504_12:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_bcacb2540a295a3d8d048738bb978f9c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_BCACB2540A295A3D8D048738BB978F9C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_BCACB2540A295A3D8D048738BB978F9C_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_6:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "nil?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_BCACB2540A295A3D8D048738BB978F9C_10;
      }
      NEXT;
    }

  // ["OP_LOADF", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_8:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 7]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_9:
  goto L_MET_BCACB2540A295A3D8D048738BB978F9C_17;
  // ["OP_MOVE", 4, 3, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_11:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_GE", 4, 2, 1]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>=);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_BCACB2540A295A3D8D048738BB978F9C_16;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_14:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_15:
  goto L_MET_BCACB2540A295A3D8D048738BB978F9C_17;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_16:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_BCACB2540A295A3D8D048738BB978F9C_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dfc5c1f3bb55b1a88d514a5788ed1f49(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_6:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "nil?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_10;
      }
      NEXT;
    }

  // ["OP_LOADF", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_8:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 7]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_9:
  goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_17;
  // ["OP_MOVE", 4, 3, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_11:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_GT", 4, 2, 1]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_16;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_14:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_15:
  goto L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_17;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_16:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_DFC5C1F3BB55B1A88D514A5788ED1F49_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d04f995d8126abb199a735d649e8f7b2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D04F995D8126ABB199A735D649E8F7B2_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D04F995D8126ABB199A735D649E8F7B2_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_EQ", 4, 1, 1]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 4; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_D04F995D8126ABB199A735D649E8F7B2_11;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_9:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_10:
  goto L_MET_D04F995D8126ABB199A735D649E8F7B2_12;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_11:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_D04F995D8126ABB199A735D649E8F7B2_12:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_01385d2338bdc15942a8eb4d9d286c65(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_01385D2338BDC15942A8EB4D9D286C65_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_01385D2338BDC15942A8EB4D9D286C65_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_6:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "nil?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_01385D2338BDC15942A8EB4D9D286C65_10;
      }
      NEXT;
    }

  // ["OP_LOADF", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_8:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 7]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_9:
  goto L_MET_01385D2338BDC15942A8EB4D9D286C65_17;
  // ["OP_MOVE", 4, 3, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_11:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_LE", 4, 2, 1]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(<=);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_01385D2338BDC15942A8EB4D9D286C65_16;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_14:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_15:
  goto L_MET_01385D2338BDC15942A8EB4D9D286C65_17;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_16:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_01385D2338BDC15942A8EB4D9D286C65_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_905652827ed690ea9daba49b80085728(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_905652827ED690EA9DABA49B80085728_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_905652827ED690EA9DABA49B80085728_1;
      }
      
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_1:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_905652827ED690EA9DABA49B80085728_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 1]
  L_MET_905652827ED690EA9DABA49B80085728_3:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_905652827ED690EA9DABA49B80085728_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 3, 0]
  L_MET_905652827ED690EA9DABA49B80085728_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_905652827ED690EA9DABA49B80085728_6:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "nil?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_905652827ED690EA9DABA49B80085728_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_905652827ED690EA9DABA49B80085728_10;
      }
      NEXT;
    }

  // ["OP_LOADF", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_8:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 7]
  L_MET_905652827ED690EA9DABA49B80085728_9:
  goto L_MET_905652827ED690EA9DABA49B80085728_17;
  // ["OP_MOVE", 4, 3, 0]
  L_MET_905652827ED690EA9DABA49B80085728_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 5, 255, 127]
  L_MET_905652827ED690EA9DABA49B80085728_11:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[5], 0);
      NEXT;
    }

  // ["OP_LT", 4, 2, 1]
  L_MET_905652827ED690EA9DABA49B80085728_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 4; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 2]
  L_MET_905652827ED690EA9DABA49B80085728_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_905652827ED690EA9DABA49B80085728_16;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_14:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_905652827ED690EA9DABA49B80085728_15:
  goto L_MET_905652827ED690EA9DABA49B80085728_17;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_16:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_905652827ED690EA9DABA49B80085728_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_495c37ccc70eea4e380b35b6e353e63a(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_905652827ed690ea9daba49b80085728, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_905652827ed690ea9daba49b80085728);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "<"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_01385d2338bdc15942a8eb4d9d286c65, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_01385d2338bdc15942a8eb4d9d286c65);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "<="), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d04f995d8126abb199a735d649e8f7b2, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d04f995d8126abb199a735d649e8f7b2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "=="), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dfc5c1f3bb55b1a88d514a5788ed1f49, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_dfc5c1f3bb55b1a88d514a5788ed1f49);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, ">"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_12:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 21]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_bcacb2540a295a3d8d048738bb978f9c, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_bcacb2540a295a3d8d048738bb978f9c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_14:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, ">="), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_15:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 25]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_16:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d84ba8bfdd06429339d63795f778b504, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d84ba8bfdd06429339d63795f778b504);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_17:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "between?"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_18:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_495C37CCC70EEA4E380B35B6E353E63A_19:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dff4cbacd9f1c9209c77d4ff07827f83(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "attr_reader"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_DFF4CBACD9F1C9209C77D4FF07827F83_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_29286821eb43a7c567fcecdc33b6180d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_29286821EB43A7C567FCECDC33B6180D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_29286821EB43A7C567FCECDC33B6180D_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 4, 4, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_2:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 4, 5, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_4:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[4],
                     mrb_ary_splat(mrb, regs[5]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 0, 127]
  L_MET_29286821EB43A7C567FCECDC33B6180D_5:
  {
      int a = 3;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "attr_reader"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_6:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_ARRAY", 4, 4, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_7:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[4] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_8:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_ARYCAT", 4, 5, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_9:
  {
      /* A B            mrb_ary_concat(R(A),R(B)) */
      mrb_ary_concat(mrb, regs[4],
                     mrb_ary_splat(mrb, regs[5]));
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 3, 1, 127]
  L_MET_29286821EB43A7C567FCECDC33B6180D_10:
  {
      int a = 3;
      int n = 127;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "attr_writer"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_29286821EB43A7C567FCECDC33B6180D_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_799ebcb21d8c8f90c8ed31fbfaedda65(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_1;
      }
      
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_1:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_2:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_4:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "instance_variable_set"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_799EBCB21D8C8F90C8ED31FBFAEDDA65_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_bb90cfc013284dab38c14f9b6e0b871b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_BB90CFC013284DAB38C14F9B6E0B871B_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_BB90CFC013284DAB38C14F9B6E0B871B_1;
      }
      
    }

  // ["OP_STRING", 4, 0, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_1:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "@");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 1, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_3:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_ADD", 4, 0, 1]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_4:
  {
      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/
      int a = 4;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x + y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x + y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(+,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(+,attr_f,attr_f);
  break;
      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
  regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_5:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "intern"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_7:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_8:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STRING", 5, 0, 1]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_9:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[5] = mrb_str_new_cstr(mrb, "=");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_ADD", 4, 0, 1]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_10:
  {
      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/
      int a = 4;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x + y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x + y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(+,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(+,attr_f,attr_f);
  break;
      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
  regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_11:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "intern"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 1, 4, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_12:
  {
      /* A B    R(A) := R(B) */
      regs[1] = regs[4];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_13:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_14:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 6, 0, 6]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_15:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_799ebcb21d8c8f90c8ed31fbfaedda65, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_799ebcb21d8c8f90c8ed31fbfaedda65);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[6] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 1]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_16:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "define_method"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_BB90CFC013284DAB38C14F9B6E0B871B_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f106a5a8902051f2f8031bbbcbe131ec(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_F106A5A8902051F2F8031BBBCBE131EC_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F106A5A8902051F2F8031BBBCBE131EC_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F106A5A8902051F2F8031BBBCBE131EC_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_F106A5A8902051F2F8031BBBCBE131EC_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_F106A5A8902051F2F8031BBBCBE131EC_2:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_bb90cfc013284dab38c14f9b6e0b871b, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_bb90cfc013284dab38c14f9b6e0b871b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_F106A5A8902051F2F8031BBBCBE131EC_3:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_F106A5A8902051F2F8031BBBCBE131EC_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3f8865894e76f32d8cebcb2fa9aceb8b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_3F8865894E76F32D8CEBCB2FA9ACEB8B_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETUPVAR", 2, 3, 0]
  L_MET_3F8865894E76F32D8CEBCB2FA9ACEB8B_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[2] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_3F8865894E76F32D8CEBCB2FA9ACEB8B_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "instance_variable_get"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 1, 0, 0]
  L_MET_3F8865894E76F32D8CEBCB2FA9ACEB8B_3:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[1];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_09a8403ea40803508ad16a6331c18f63(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_09A8403EA40803508AD16A6331C18F63_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_09A8403EA40803508AD16A6331C18F63_1;
      }
      
    }

  // ["OP_STRING", 4, 0, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_1:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[4] = mrb_str_new_cstr(mrb, "@");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_2:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 1, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_3:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "to_s"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_ADD", 4, 0, 1]
  L_MET_09A8403EA40803508AD16A6331C18F63_4:
  {
      /* A B C  R(A) := R(A)+R(A+1) (Syms[B]=:+,C=1)*/
      int a = 4;

      /* need to check if op is overridden */
      switch (TYPES2(mrb_type(regs[a]),mrb_type(regs[a+1]))) {
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FIXNUM):
  {
    mrb_int x, y, z;

    x = mrb_fixnum(regs[a]);
    y = mrb_fixnum(regs[a+1]);
    z = x + y;
    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    SET_INT_VALUE(regs[a], z);
  }
  break;
      case TYPES2(MRB_TT_FIXNUM,MRB_TT_FLOAT):
  {
    mrb_int x = mrb_fixnum(regs[a]);
    mrb_float y = mrb_float(regs[a+1]);
    SET_FLT_VALUE(regs[a], (mrb_float)x + y);
  }
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FIXNUM):
  OP_MATH_BODY(+,attr_f,attr_i);
  break;
      case TYPES2(MRB_TT_FLOAT,MRB_TT_FLOAT):
  OP_MATH_BODY(+,attr_f,attr_f);
  break;
      case TYPES2(MRB_TT_STRING,MRB_TT_STRING):
  regs[a] = mrb_str_plus(mrb, regs[a], regs[a+1]);
  break;
      default:
  regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 4, 2, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_5:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "intern"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 4, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[4];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_7:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_8:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 6, 0, 6]
  L_MET_09A8403EA40803508AD16A6331C18F63_9:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3f8865894e76f32d8cebcb2fa9aceb8b, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_3f8865894e76f32d8cebcb2fa9aceb8b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[6] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 3, 1]
  L_MET_09A8403EA40803508AD16A6331C18F63_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "define_method"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_09A8403EA40803508AD16A6331C18F63_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0d7ae05d5e4c5894f51cda03090f7ee9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 0]
  L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4096;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_2:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_09a8403ea40803508ad16a6331c18f63, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_09a8403ea40803508ad16a6331c18f63);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_3:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_0D7AE05D5E4C5894F51CDA03090F7EE9_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_669e9055cb511bf8fa47a11463cd4434(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_669E9055CB511BF8FA47A11463CD4434_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0d7ae05d5e4c5894f51cda03090f7ee9, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0d7ae05d5e4c5894f51cda03090f7ee9);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "attr_reader"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_669E9055CB511BF8FA47A11463CD4434_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f106a5a8902051f2f8031bbbcbe131ec, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f106a5a8902051f2f8031bbbcbe131ec);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "attr_writer"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 29]
  L_MET_669E9055CB511BF8FA47A11463CD4434_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_29286821eb43a7c567fcecdc33b6180d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_29286821eb43a7c567fcecdc33b6180d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "attr_accessor"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 33]
  L_MET_669E9055CB511BF8FA47A11463CD4434_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dff4cbacd9f1c9209c77d4ff07827f83, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_dff4cbacd9f1c9209c77d4ff07827f83);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "attr"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_12:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_669E9055CB511BF8FA47A11463CD4434_13:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0fb1ef4d91d2c45370cdda3c8856373f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_0FB1EF4D91D2C45370CDDA3C8856373F_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_630e760ee96651bfda5de9cb645faad5(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (10 < 3) ? 3 : 10, 3);
  }
  else {
    stack_extend(mrb, 10, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 10 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_630E760EE96651BFDA5DE9CB645FAAD5_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_630E760EE96651BFDA5DE9CB645FAAD5_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0fb1ef4d91d2c45370cdda3c8856373f, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_0fb1ef4d91d2c45370cdda3c8856373f);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_5:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "empty?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_630E760EE96651BFDA5DE9CB645FAAD5_9;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 14]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_8:
  goto L_MET_630E760EE96651BFDA5DE9CB645FAAD5_23;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_9:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_OCLASS", 5, 0, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_11:
  {
      /* A      R(A) := ::Object */
      regs[5] = mrb_obj_value(mrb->object_class);
      NEXT;
    }

  // ["OP_GETMCNST", 5, 0, 3]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_12:
  {
      /* A B C  R(A) := R(C)::Sym(B) */
      int a = 5;

      regs[a] = mrb_const_get(mrb, regs[a], mrb_intern(mrb, "Array"));
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_13:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 6, 5, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_14:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 5, 4, 1]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_15:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "new"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 6, 255, 127]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_16:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 0);
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 127]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_17:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 0);
      NEXT;
    }

  // ["OP_MOVE", 8, 2, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_18:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 8, 5, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_19:
  {
      int a = 8;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SUBI", 8, 6, 1]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_20:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 8;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 9, 1, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_21:
  {
      /* A B    R(A) := R(B) */
      regs[9] = regs[1];
      NEXT;
    }

  // ["OP_SENDB", 3, 2, 5]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_22:
  {
      int a = 3;
      int n = 5;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__sort_sub__"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_630E760EE96651BFDA5DE9CB645FAAD5_23:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5601cbe76a696a1313c317b664a3aac6(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_5601CBE76A696A1313C317B664A3AAC6_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_5601CBE76A696A1313C317B664A3AAC6_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 6, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 6);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 7]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_5601CBE76A696A1313C317B664A3AAC6_10;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 6, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_3:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 6);
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 7, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_4:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 7);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 5, 9, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_7:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 9);
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_8:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 5]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_9:
  goto L_MET_5601CBE76A696A1313C317B664A3AAC6_15;
  // ["OP_GETUPVAR", 3, 7, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_10:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 7);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_11:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_12:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 9, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_13:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 9);
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_14:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_15:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_GT", 3, 3, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_16:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 11]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_17:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_5601CBE76A696A1313C317B664A3AAC6_29;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 7, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_18:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 7);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_19:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_20:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 8, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_21:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 8);
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 11, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_22:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 11);
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_23:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 2]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_24:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 3, 11, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_25:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 11);
      NEXT;
    }

  // ["OP_SUBI", 3, 5, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_26:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 11, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_27:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 11, regs[3]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 10]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_28:
  goto L_MET_5601CBE76A696A1313C317B664A3AAC6_39;
  // ["OP_GETUPVAR", 3, 7, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_29:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 7);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_30:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_31:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 4, 8, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_32:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 8);
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 10, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_33:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 10);
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_34:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 2]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_35:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 3, 10, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_36:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 10);
      NEXT;
    }

  // ["OP_ADDI", 3, 6, 1]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_37:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 10, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_38:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 10, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_5601CBE76A696A1313C317B664A3AAC6_39:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_5b6e81c9814928c26fcd30c039b1d23b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (19 < 3) ? 3 : 19, 3);
  }
  else {
    stack_extend(mrb, 19, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 19 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 20, 0, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1310721;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_1;
      }
      
    }

  // ["OP_MOVE", 12, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_1:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 13, 5, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_2:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[5];
      NEXT;
    }

  // ["OP_EQ", 12, 0, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 12;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 12; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 12, 256, 12]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[12])) {
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_17;
      }
      NEXT;
    }

  // ["OP_MOVE", 12, 3, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_5:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 13, 256, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_6:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[13], 1);
      NEXT;
    }

  // ["OP_EQ", 12, 0, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_7:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 12;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 12; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 12, 256, 7]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[12])) {
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_16;
      }
      NEXT;
    }

  // ["OP_MOVE", 12, 2, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_9:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 13, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_10:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 12, 1, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_11:
  {
      int a = 12;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 13, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_12:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 14, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_13:
  {
      /* A B    R(A) := R(B) */
      regs[14] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 15, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_14:
  {
      /* A B    R(A) := R(B) */
      regs[15] = regs[12];
      NEXT;
    }

  // ["OP_SEND", 13, 2, 2]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_15:
  {
      int a = 13;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 11, 0, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_16:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[11];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_MOVE", 12, 3, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_17:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[3];
      NEXT;
    }

  // ["OP_LOADI", 13, 255, 127]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_18:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[13], 0);
      NEXT;
    }

  // ["OP_EQ", 12, 0, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_19:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 12;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 12; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 12, 256, 5]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_20:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[12])) {
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_26;
      }
      NEXT;
    }

  // ["OP_MOVE", 12, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_21:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 13, 2, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_22:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 7, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_23:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[12];
      NEXT;
    }

  // ["OP_MOVE", 8, 13, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_24:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[13];
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_25:
  goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_30;
  // ["OP_MOVE", 12, 2, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_26:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 13, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_27:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 7, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_28:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[12];
      NEXT;
    }

  // ["OP_MOVE", 8, 13, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_29:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[13];
      NEXT;
    }

  // ["OP_MOVE", 12, 7, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_30:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[7];
      NEXT;
    }

  // ["OP_MOVE", 13, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_31:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 12, 1, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_32:
  {
      int a = 12;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 9, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_33:
  {
      /* A B    R(A) := R(B) */
      regs[9] = regs[12];
      NEXT;
    }

  // ["OP_MOVE", 12, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_34:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 13, 5, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_35:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 10, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_36:
  {
      /* A B    R(A) := R(B) */
      regs[10] = regs[12];
      NEXT;
    }

  // ["OP_MOVE", 11, 13, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_37:
  {
      /* A B    R(A) := R(B) */
      regs[11] = regs[13];
      NEXT;
    }

  // ["OP_MOVE", 12, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_38:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[4];
      NEXT;
    }

  // ["OP_ADDI", 12, 3, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_39:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 12;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 13, 5, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_40:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[5];
      NEXT;
    }

  // ["OP_LAMBDA", 14, 0, 6]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_41:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5601cbe76a696a1313c317b664a3aac6, (unsigned int)12);
      }
      else {
        p = mrbb_proc_new(mrb, met_5601cbe76a696a1313c317b664a3aac6);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[14] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 12, 4, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_42:
  {
      int a = 12;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "upto"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 12, 9, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_43:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[9];
      NEXT;
    }

  // ["OP_MOVE", 13, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_44:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 14, 10, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_45:
  {
      /* A B    R(A) := R(B) */
      regs[14] = regs[10];
      NEXT;
    }

  // ["OP_MOVE", 15, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_46:
  {
      /* A B    R(A) := R(B) */
      regs[15] = regs[12];
      NEXT;
    }

  // ["OP_SEND", 13, 2, 2]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_47:
  {
      int a = 13;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 12, 3, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_48:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[3];
      NEXT;
    }

  // ["OP_ADDI", 12, 3, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_49:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 12;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_LOADI", 13, 256, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_50:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[13], 2);
      NEXT;
    }

  // ["OP_SEND", 12, 5, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_51:
  {
      int a = 12;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "%"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 12, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_52:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[12];
      NEXT;
    }

  // ["OP_MOVE", 12, 10, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_53:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[10];
      NEXT;
    }

  // ["OP_MOVE", 13, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_54:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[4];
      NEXT;
    }

  // ["OP_GT", 12, 6, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_55:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 12; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 12, 256, 9]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_56:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[12])) {
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_66;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 12, 0, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_57:
  {
      /* A      R(A) := self */
      regs[12] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 13, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_58:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 14, 2, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_59:
  {
      /* A B    R(A) := R(B) */
      regs[14] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 15, 3, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_60:
  {
      /* A B    R(A) := R(B) */
      regs[15] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 16, 4, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_61:
  {
      /* A B    R(A) := R(B) */
      regs[16] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 17, 10, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_62:
  {
      /* A B    R(A) := R(B) */
      regs[17] = regs[10];
      NEXT;
    }

  // ["OP_SUBI", 17, 8, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_63:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 17;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 18, 6, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_64:
  {
      /* A B    R(A) := R(B) */
      regs[18] = regs[6];
      NEXT;
    }

  // ["OP_SENDB", 12, 7, 5]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_65:
  {
      int a = 12;
      int n = 5;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__sort_sub__"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 12, 10, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_66:
  {
      /* A B    R(A) := R(B) */
      regs[12] = regs[10];
      NEXT;
    }

  // ["OP_MOVE", 13, 5, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_67:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[5];
      NEXT;
    }

  // ["OP_LT", 12, 9, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_68:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 12; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPNOT", 12, 256, 10]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_69:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[12])) {
        goto L_MET_5B6E81C9814928C26FCD30C039B1D23B_80;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 12, 0, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_70:
  {
      /* A      R(A) := self */
      regs[12] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 13, 1, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_71:
  {
      /* A B    R(A) := R(B) */
      regs[13] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 14, 2, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_72:
  {
      /* A B    R(A) := R(B) */
      regs[14] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 15, 3, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_73:
  {
      /* A B    R(A) := R(B) */
      regs[15] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 16, 10, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_74:
  {
      /* A B    R(A) := R(B) */
      regs[16] = regs[10];
      NEXT;
    }

  // ["OP_ADDI", 16, 3, 1]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_75:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 16;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 17, 5, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_76:
  {
      /* A B    R(A) := R(B) */
      regs[17] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 18, 6, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_77:
  {
      /* A B    R(A) := R(B) */
      regs[18] = regs[6];
      NEXT;
    }

  // ["OP_SENDB", 12, 7, 5]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_78:
  {
      int a = 12;
      int n = 5;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "__sort_sub__"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 12, 0, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_79:
  {
      /* A B    R(A) := nil */
      int a = 12;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 12, 0, 0]
  L_MET_5B6E81C9814928C26FCD30C039B1D23B_80:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[12];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_869652b8713a9060f4075c1594127d0b(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_869652B8713A9060F4075C1594127D0B_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_869652B8713A9060F4075C1594127D0B_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_869652B8713A9060F4075C1594127D0B_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_869652B8713A9060F4075C1594127D0B_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_869652B8713A9060F4075C1594127D0B_6;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_869652B8713A9060F4075C1594127D0B_5:
  goto L_MET_869652B8713A9060F4075C1594127D0B_9;
  // ["OP_GETUPVAR", 2, 2, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_6:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[2] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_7:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 2, 1, 1]
  L_MET_869652B8713A9060F4075C1594127D0B_8:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_869652B8713A9060F4075C1594127D0B_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_adc0b53b287718a57d70a31162d700ea(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_ADC0B53B287718A57D70A31162D700EA_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_ADC0B53B287718A57D70A31162D700EA_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_ADC0B53B287718A57D70A31162D700EA_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_ADC0B53B287718A57D70A31162D700EA_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_ADC0B53B287718A57D70A31162D700EA_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_ADC0B53B287718A57D70A31162D700EA_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_869652b8713a9060f4075c1594127d0b, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_869652b8713a9060f4075c1594127d0b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_ADC0B53B287718A57D70A31162D700EA_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_ADC0B53B287718A57D70A31162D700EA_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ea902a06773c92a44f103d6eaab1107c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_EA902A06773C92A44F103D6EAAB1107C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_EA902A06773C92A44F103D6EAAB1107C_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_EA902A06773C92A44F103D6EAAB1107C_9;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_8:
  goto L_MET_EA902A06773C92A44F103D6EAAB1107C_12;
  // ["OP_GETUPVAR", 3, 3, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_9:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_11:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_EA902A06773C92A44F103D6EAAB1107C_12:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_22517d378bf2ebfdf0380a74d22a57a1(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_22517D378BF2EBFDF0380A74D22A57A1_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_22517D378BF2EBFDF0380A74D22A57A1_1;
      }
      
    }

  // ["OP_ARRAY", 2, 4, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_ARRAY", 3, 4, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_2:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[3] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_3:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ea902a06773c92a44f103d6eaab1107c, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_ea902a06773c92a44f103d6eaab1107c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_5:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_7:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_ARRAY", 0, 4, 2]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_8:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[0] = mrb_ary_new_from_values(mrb, 2, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_22517D378BF2EBFDF0380A74D22A57A1_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_dde2409d49e847f87f86337c9512f766(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DDE2409D49E847F87F86337C9512F766_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DDE2409D49E847F87F86337C9512F766_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_DDE2409D49E847F87F86337C9512F766_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_DDE2409D49E847F87F86337C9512F766_7;
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 1, 3, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_3:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[1]);
      NEXT;
    }

  // ["OP_LOADF", 3, 0, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_4:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 2, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_5:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[3]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 22]
  L_MET_DDE2409D49E847F87F86337C9512F766_6:
  goto L_MET_DDE2409D49E847F87F86337C9512F766_29;
  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_7:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 11]
  L_MET_DDE2409D49E847F87F86337C9512F766_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_DDE2409D49E847F87F86337C9512F766_20;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_9:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 3, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_11:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_DDE2409D49E847F87F86337C9512F766_12:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_DDE2409D49E847F87F86337C9512F766_13:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_LT", 3, 1, 1]
  L_MET_DDE2409D49E847F87F86337C9512F766_14:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_DDE2409D49E847F87F86337C9512F766_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_DDE2409D49E847F87F86337C9512F766_19;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_16:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 3, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_17:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[3]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_18:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 9]
  L_MET_DDE2409D49E847F87F86337C9512F766_19:
  goto L_MET_DDE2409D49E847F87F86337C9512F766_29;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_20:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_21:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_DDE2409D49E847F87F86337C9512F766_22:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_DDE2409D49E847F87F86337C9512F766_23:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_LT", 3, 1, 1]
  L_MET_DDE2409D49E847F87F86337C9512F766_24:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_DDE2409D49E847F87F86337C9512F766_25:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_DDE2409D49E847F87F86337C9512F766_29;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_26:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 3, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_27:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[3]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_28:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_DDE2409D49E847F87F86337C9512F766_29:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_bee404f8c801a5e6ffaa460a796fac46(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_BEE404F8C801A5E6FFAA460A796FAC46_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_BEE404F8C801A5E6FFAA460A796FAC46_1;
      }
      
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_2:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_3:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dde2409d49e847f87f86337c9512f766, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_dde2409d49e847f87f86337c9512f766);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_5:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_BEE404F8C801A5E6FFAA460A796FAC46_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_6074b99412f217edd6e853c14f28e02c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_6074B99412F217EDD6E853C14F28E02C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_6074B99412F217EDD6E853C14F28E02C_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_6074B99412F217EDD6E853C14F28E02C_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_6074B99412F217EDD6E853C14F28E02C_7;
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 1, 3, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_3:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[1]);
      NEXT;
    }

  // ["OP_LOADF", 3, 0, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_4:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 2, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_5:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[3]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 22]
  L_MET_6074B99412F217EDD6E853C14F28E02C_6:
  goto L_MET_6074B99412F217EDD6E853C14F28E02C_29;
  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_7:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 11]
  L_MET_6074B99412F217EDD6E853C14F28E02C_8:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_6074B99412F217EDD6E853C14F28E02C_20;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_9:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_10:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 3, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_11:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_6074B99412F217EDD6E853C14F28E02C_12:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_6074B99412F217EDD6E853C14F28E02C_13:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_GT", 3, 1, 1]
  L_MET_6074B99412F217EDD6E853C14F28E02C_14:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_6074B99412F217EDD6E853C14F28E02C_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_6074B99412F217EDD6E853C14F28E02C_19;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_16:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 3, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_17:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[3]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_18:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 9]
  L_MET_6074B99412F217EDD6E853C14F28E02C_19:
  goto L_MET_6074B99412F217EDD6E853C14F28E02C_29;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_20:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 3, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_21:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_SEND", 3, 2, 1]
  L_MET_6074B99412F217EDD6E853C14F28E02C_22:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "<=>"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_6074B99412F217EDD6E853C14F28E02C_23:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_GT", 3, 1, 1]
  L_MET_6074B99412F217EDD6E853C14F28E02C_24:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_6074B99412F217EDD6E853C14F28E02C_25:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_6074B99412F217EDD6E853C14F28E02C_29;
      }
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_26:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 3, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_27:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[3]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_28:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_6074B99412F217EDD6E853C14F28E02C_29:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_63c0ee75c95ed465fe8ca962deb6b9d9(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_1;
      }
      
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_2:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_3:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_6074b99412f217edd6e853c14f28e02c, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_6074b99412f217edd6e853c14f28e02c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_5:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_63C0EE75C95ED465FE8CA962DEB6B9D9_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_94785036ddeef421621747c58d3365c8(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_94785036DDEEF421621747C58D3365C8_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_94785036DDEEF421621747C58D3365C8_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 4, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 4);
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 5]
  L_MET_94785036DDEEF421621747C58D3365C8_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_94785036DDEEF421621747C58D3365C8_8;
      }
      NEXT;
    }

  // ["OP_LOADF", 3, 0, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_3:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 4, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_4:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 4, regs[3]);
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_5:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 5, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_6:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 5, regs[3]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 5]
  L_MET_94785036DDEEF421621747C58D3365C8_7:
  goto L_MET_94785036DDEEF421621747C58D3365C8_13;
  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_8:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 5, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_9:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 5);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_10:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_94785036DDEEF421621747C58D3365C8_11:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SETUPVAR", 3, 5, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_12:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 5, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_94785036DDEEF421621747C58D3365C8_13:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3b4a49e6c2d2b509242d582bee16cd02(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 8, 0, 0]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 524288;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_3B4A49E6C2D2B509242D582BEE16CD02_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_3B4A49E6C2D2B509242D582BEE16CD02_1;
      }
      
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_1:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 3, 0]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_2:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_MOVE", 6, 2, 0]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_3:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 0, 2]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_4:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "send"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 4, 0, 0]
  L_MET_3B4A49E6C2D2B509242D582BEE16CD02_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[4];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_732ba98d632e75b51348a436666fd59c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (9 < 3) ? 3 : 9, 3);
  }
  else {
    stack_extend(mrb, 9, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 9 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 32, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 4097;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_732BA98D632E75B51348A436666FD59C_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_732BA98D632E75B51348A436666FD59C_1;
      }
      
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_1:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_2:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "size"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 7, 256, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_3:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 2);
      NEXT;
    }

  // ["OP_GT", 6, 1, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_4:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 6; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 6, 256, 4]
  L_MET_732BA98D632E75B51348A436666FD59C_5:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_732BA98D632E75B51348A436666FD59C_10;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_6:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 7, 0, 3]
  L_MET_732BA98D632E75B51348A436666FD59C_7:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[7] = mrb_vm_const_get(mrb, mrb_intern(mrb, "ArgumentError"));
      NEXT;
    }

  // ["OP_STRING", 8, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_8:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[8] = mrb_str_new_cstr(mrb, "too many arguments");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 6, 2, 2]
  L_MET_732BA98D632E75B51348A436666FD59C_9:
  {
      int a = 6;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 6, 0, 4]
  L_MET_732BA98D632E75B51348A436666FD59C_10:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Symbol"));
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_11:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 8, 255, 126]
  L_MET_732BA98D632E75B51348A436666FD59C_12:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[8], -1);
      NEXT;
    }

  // ["OP_SEND", 7, 6, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_13:
  {
      int a = 7;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 6, 5, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_14:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "==="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 6, 256, 8]
  L_MET_732BA98D632E75B51348A436666FD59C_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_732BA98D632E75B51348A436666FD59C_24;
      }
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_16:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 126]
  L_MET_732BA98D632E75B51348A436666FD59C_17:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], -1);
      NEXT;
    }

  // ["OP_SEND", 6, 6, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_18:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 6, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_19:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[6];
      NEXT;
    }

  // ["OP_LAMBDA", 6, 0, 7]
  L_MET_732BA98D632E75B51348A436666FD59C_20:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 3;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3b4a49e6c2d2b509242d582bee16cd02, (unsigned int)6);
      }
      else {
        p = mrbb_proc_new(mrb, met_3b4a49e6c2d2b509242d582bee16cd02);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[6] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_MOVE", 2, 6, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_21:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[6];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_22:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 7, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_23:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "pop"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_24:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 6, 8, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_25:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "empty?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 6, 256, 3]
  L_MET_732BA98D632E75B51348A436666FD59C_26:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[6])) {
        goto L_MET_732BA98D632E75B51348A436666FD59C_30;
      }
      NEXT;
    }

  // ["OP_LOADT", 4, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_27:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_28:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 5]
  L_MET_732BA98D632E75B51348A436666FD59C_29:
  goto L_MET_732BA98D632E75B51348A436666FD59C_35;
  // ["OP_LOADF", 4, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_30:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[4]);
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_31:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 7, 255, 127]
  L_MET_732BA98D632E75B51348A436666FD59C_32:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[7], 0);
      NEXT;
    }

  // ["OP_SEND", 6, 6, 1]
  L_MET_732BA98D632E75B51348A436666FD59C_33:
  {
      int a = 6;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 6, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_34:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[6];
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_35:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 7, 0, 10]
  L_MET_732BA98D632E75B51348A436666FD59C_36:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_94785036ddeef421621747c58d3365c8, (unsigned int)6);
      }
      else {
        p = mrbb_proc_new(mrb, met_94785036ddeef421621747c58d3365c8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[7] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 6, 9, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_37:
  {
      int a = 6;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 5, 0, 0]
  L_MET_732BA98D632E75B51348A436666FD59C_38:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[5];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2a9aeb3f46e70a98fa0c3309beca56fd(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_2:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_EQ", 3, 0, 1]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_3:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 3; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_9;
      }
      NEXT;
    }

  // ["OP_LOADT", 3, 0, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_5:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 3, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_6:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 1, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_8:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_2A9AEB3F46E70A98FA0C3309BECA56FD_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_43b92a37d49a7595f8cc10d45be754ec(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_43B92A37D49A7595F8CC10D45BE754EC_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_43B92A37D49A7595F8CC10D45BE754EC_1;
      }
      
    }

  // ["OP_LOADF", 3, 0, 0]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_1:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2a9aeb3f46e70a98fa0c3309beca56fd, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_2a9aeb3f46e70a98fa0c3309beca56fd);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_4:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_43B92A37D49A7595F8CC10D45BE754EC_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_acb8b7f39079b85db17285de2ea8b0e7(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "==="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 10]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_15;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 3, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 3);
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 2, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_6:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_JMPNOT", 4, 256, 4]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_7:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[4])) {
        goto L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_12;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 2, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_8:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_9:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 1]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_10:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 1]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_11:
  goto L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_13;
  // ["OP_MOVE", 4, 1, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_12:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_13:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_14:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_ACB8B7F39079B85DB17285DE2EA8B0E7_15:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0a0c5407ae7053dcc05b25295567da59(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0A0C5407AE7053DCC05B25295567DA59_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0A0C5407AE7053DCC05B25295567DA59_1;
      }
      
    }

  // ["OP_ARRAY", 3, 4, 0]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[3] = mrb_ary_new_from_values(mrb, 0, &regs[4]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_acb8b7f39079b85db17285de2ea8b0e7, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_acb8b7f39079b85db17285de2ea8b0e7);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_4:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_0A0C5407AE7053DCC05B25295567DA59_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_94b037a1e79a5939278190b447d24ab0(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_94B037A1E79A5939278190B447D24AB0_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_94B037A1E79A5939278190B447D24AB0_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_94B037A1E79A5939278190B447D24AB0_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_94B037A1E79A5939278190B447D24AB0_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_94B037A1E79A5939278190B447D24AB0_9;
      }
      NEXT;
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_6:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 1, 1]
  L_MET_94B037A1E79A5939278190B447D24AB0_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_8:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_94B037A1E79A5939278190B447D24AB0_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_0986ead61ec860c5ca98c2077076740d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_0986EAD61EC860C5CA98C2077076740D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_0986EAD61EC860C5CA98C2077076740D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_0986EAD61EC860C5CA98C2077076740D_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_0986EAD61EC860C5CA98C2077076740D_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_0986EAD61EC860C5CA98C2077076740D_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_0986EAD61EC860C5CA98C2077076740D_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_94b037a1e79a5939278190b447d24ab0, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_94b037a1e79a5939278190b447d24ab0);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_0986EAD61EC860C5CA98C2077076740D_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_0986EAD61EC860C5CA98C2077076740D_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_d16027aed046ea313eca86aa7f2a6696(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_D16027AED046EA313ECA86AA7F2A6696_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_D16027AED046EA313ECA86AA7F2A6696_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_D16027AED046EA313ECA86AA7F2A6696_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_D16027AED046EA313ECA86AA7F2A6696_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_D16027AED046EA313ECA86AA7F2A6696_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_D16027AED046EA313ECA86AA7F2A6696_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_D16027AED046EA313ECA86AA7F2A6696_4:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_08d9abbe248dc5305d5ef39d22a6705d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 0]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 0;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_08D9ABBE248DC5305D5EF39D22A6705D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_08D9ABBE248DC5305D5EF39D22A6705D_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d16027aed046ea313eca86aa7f2a6696, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_d16027aed046ea313eca86aa7f2a6696);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_08D9ABBE248DC5305D5EF39D22A6705D_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_e83849d487478dda35faeff7ce83f8c4(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_E83849D487478DDA35FAEFF7CE83F8C4_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_E83849D487478DDA35FAEFF7CE83F8C4_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_GETUPVAR", 5, 2, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_3:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[5] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_SEND", 3, 0, 2]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_4:
  {
      int a = 3;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_5:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_ADDI", 3, 1, 1]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_6:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 2, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_7:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_E83849D487478DDA35FAEFF7CE83F8C4_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_595de9d2202c3341c9829b1aef0c918f(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_595DE9D2202C3341C9829B1AEF0C918F_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_595DE9D2202C3341C9829B1AEF0C918F_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_e83849d487478dda35faeff7ce83f8c4, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_e83849d487478dda35faeff7ce83f8c4);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_5:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_595DE9D2202C3341C9829B1AEF0C918F_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_2ef66cc091222ca80b1069fcb6bc2e29(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_2EF66CC091222CA80B1069FCB6BC2E29_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_2EF66CC091222CA80B1069FCB6BC2E29_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 3]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_2EF66CC091222CA80B1069FCB6BC2E29_8;
      }
      NEXT;
    }

  // ["OP_SETUPVAR", 1, 3, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_5:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 3, regs[1]);
      NEXT;
    }

  // ["OP_RETURN", 3, 1, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_7:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_2EF66CC091222CA80B1069FCB6BC2E29_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_a73aef5e795e6acdb33e737a74ca788c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 64, 1]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 8193;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
  
    switch(argc) {
  case 0: goto L_MET_A73AEF5E795E6ACDB33E737A74CA788C_1;
}

      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_A73AEF5E795E6ACDB33E737A74CA788C_2;
      }
      
    }

  // ["OP_JMP", 0, 256, 1]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_1:
  goto L_MET_A73AEF5E795E6ACDB33E737A74CA788C_3;
  // ["OP_JMP", 0, 256, 1]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_2:
  goto L_MET_A73AEF5E795E6ACDB33E737A74CA788C_4;
  // ["OP_LOADNIL", 1, 0, 0]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_3:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_4:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_5:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 5, 0, 6]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_6:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2ef66cc091222ca80b1069fcb6bc2e29, (unsigned int)4);
      }
      else {
        p = mrbb_proc_new(mrb, met_2ef66cc091222ca80b1069fcb6bc2e29);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[5] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 4, 0, 0]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_7:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_A73AEF5E795E6ACDB33E737A74CA788C_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_c73910648aa94076ab2d158952c0b326(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_C73910648AA94076AB2D158952C0B326_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_C73910648AA94076AB2D158952C0B326_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_C73910648AA94076AB2D158952C0B326_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 2, 0]
  L_MET_C73910648AA94076AB2D158952C0B326_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 2);
      NEXT;
    }

  // ["OP_GETUPVAR", 4, 1, 0]
  L_MET_C73910648AA94076AB2D158952C0B326_2:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[4] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_C73910648AA94076AB2D158952C0B326_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_C73910648AA94076AB2D158952C0B326_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_C73910648AA94076AB2D158952C0B326_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "push"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_C73910648AA94076AB2D158952C0B326_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_e18b0430d51d4880f006681ce44d209e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_E18B0430D51D4880F006681CE44D209E_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_E18B0430D51D4880F006681CE44D209E_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_E18B0430D51D4880F006681CE44D209E_1;
      }
      
    }

  // ["OP_ARRAY", 2, 3, 0]
  L_MET_E18B0430D51D4880F006681CE44D209E_1:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[2] = mrb_ary_new_from_values(mrb, 0, &regs[3]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_E18B0430D51D4880F006681CE44D209E_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_E18B0430D51D4880F006681CE44D209E_3:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_c73910648aa94076ab2d158952c0b326, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_c73910648aa94076ab2d158952c0b326);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_E18B0430D51D4880F006681CE44D209E_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_E18B0430D51D4880F006681CE44D209E_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_40ce86e6c6e280838460e6ae0cfc91b2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_40CE86E6C6E280838460E6AE0CFC91B2_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_40CE86E6C6E280838460E6AE0CFC91B2_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_40CE86E6C6E280838460E6AE0CFC91B2_7;
      }
      NEXT;
    }

  // ["OP_LOADT", 3, 0, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_3:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 2, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_4:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 1, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_6:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_40CE86E6C6E280838460E6AE0CFC91B2_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_daf63b08b920cd070e6204ef61625973(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_DAF63B08B920CD070E6204EF61625973_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_DAF63B08B920CD070E6204EF61625973_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_DAF63B08B920CD070E6204EF61625973_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_DAF63B08B920CD070E6204EF61625973_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_DAF63B08B920CD070E6204EF61625973_9;
      }
      NEXT;
    }

  // ["OP_LOADT", 3, 0, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_5:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[3]);
      NEXT;
    }

  // ["OP_SETUPVAR", 3, 2, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_6:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[3]);
      NEXT;
    }

  // ["OP_RETURN", 3, 1, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_LOADNIL", 3, 0, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_8:
  {
      /* A B    R(A) := nil */
      int a = 3;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_DAF63B08B920CD070E6204EF61625973_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_ca42e4bb65f515c9b06391ade4bacec0(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_1;
      }
      
    }

  // ["OP_LOADF", 2, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_1:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_2:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_3:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_8;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_4:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_5:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_daf63b08b920cd070e6204ef61625973, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_daf63b08b920cd070e6204ef61625973);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_7:
  goto L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_11;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_8:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 10]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_9:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_40ce86e6c6e280838460e6ae0cfc91b2, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_40ce86e6c6e280838460e6ae0cfc91b2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_10:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_CA42E4BB65F515C9B06391ADE4BACEC0_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_54117f09ee2a486b846f6188056afdf4(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_54117F09EE2A486B846F6188056AFDF4_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_54117F09EE2A486B846F6188056AFDF4_1;
      }
      
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_1:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_54117F09EE2A486B846F6188056AFDF4_2:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_54117F09EE2A486B846F6188056AFDF4_4;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_54117F09EE2A486B846F6188056AFDF4_3:
  goto L_MET_54117F09EE2A486B846F6188056AFDF4_7;
  // ["OP_LOADF", 2, 0, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_4:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SETUPVAR", 2, 2, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_5:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[2]);
      NEXT;
    }

  // ["OP_RETURN", 2, 1, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_54117F09EE2A486B846F6188056AFDF4_7:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_7b7da3dd645a3a3e0d199b36fda801fa(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_2:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_3:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 3, 256, 1]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_4:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_6;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 3]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_5:
  goto L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_9;
  // ["OP_LOADF", 2, 0, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_6:
  {
      /* A      R(A) := false */
      SET_FALSE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_SETUPVAR", 2, 2, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_7:
  {
      /* A B C  uvset(B,C,R(A)) */
      uvset(mrb, 0, 2, regs[2]);
      NEXT;
    }

  // ["OP_RETURN", 2, 1, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_8:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (1) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_7B7DA3DD645A3A3E0D199B36FDA801FA_9:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f5fb6124b3a6237e51ef4d58619524ec(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F5FB6124B3A6237E51EF4D58619524EC_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F5FB6124B3A6237E51EF4D58619524EC_1;
      }
      
    }

  // ["OP_LOADT", 2, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_1:
  {
      /* A      R(A) := true */
      SET_TRUE_VALUE(regs[2]);
      NEXT;
    }

  // ["OP_MOVE", 3, 1, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_2:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_JMPNOT", 3, 256, 4]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_3:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[3])) {
        goto L_MET_F5FB6124B3A6237E51EF4D58619524EC_8;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_4:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 6]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_5:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_7b7da3dd645a3a3e0d199b36fda801fa, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_7b7da3dd645a3a3e0d199b36fda801fa);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_6:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 3]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_7:
  goto L_MET_F5FB6124B3A6237E51EF4D58619524EC_11;
  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_8:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 4, 0, 10]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_9:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_54117f09ee2a486b846f6188056afdf4, (unsigned int)3);
      }
      else {
        p = mrbb_proc_new(mrb, met_54117f09ee2a486b846f6188056afdf4);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 3, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_10:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_F5FB6124B3A6237E51EF4D58619524EC_11:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_016617f0ae51761167d8f971d65ff65c(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_016617F0AE51761167D8F971D65FF65C_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f5fb6124b3a6237e51ef4d58619524ec, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f5fb6124b3a6237e51ef4d58619524ec);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "all?"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 17]
  L_MET_016617F0AE51761167D8F971D65FF65C_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ca42e4bb65f515c9b06391ade4bacec0, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_ca42e4bb65f515c9b06391ade4bacec0);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "any?"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 29]
  L_MET_016617F0AE51761167D8F971D65FF65C_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_e18b0430d51d4880f006681ce44d209e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_e18b0430d51d4880f006681ce44d209e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "collect"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 37]
  L_MET_016617F0AE51761167D8F971D65FF65C_10:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a73aef5e795e6acdb33e737a74ca788c, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a73aef5e795e6acdb33e737a74ca788c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_11:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "detect"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_12:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 45]
  L_MET_016617F0AE51761167D8F971D65FF65C_13:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_595de9d2202c3341c9829b1aef0c918f, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_595de9d2202c3341c9829b1aef0c918f);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 4, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_14:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_with_index"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_15:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 53]
  L_MET_016617F0AE51761167D8F971D65FF65C_16:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_08d9abbe248dc5305d5ef39d22a6705d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_08d9abbe248dc5305d5ef39d22a6705d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_17:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "entries"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_18:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 6]
  L_MET_016617F0AE51761167D8F971D65FF65C_19:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "find"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 3]
  L_MET_016617F0AE51761167D8F971D65FF65C_20:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "detect"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_21:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_22:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_23:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 61]
  L_MET_016617F0AE51761167D8F971D65FF65C_24:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0986ead61ec860c5ca98c2077076740d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0986ead61ec860c5ca98c2077076740d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 8, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_25:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "find_all"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_26:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 69]
  L_MET_016617F0AE51761167D8F971D65FF65C_27:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0a0c5407ae7053dcc05b25295567da59, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0a0c5407ae7053dcc05b25295567da59);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 9, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_28:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "grep"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_29:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 77]
  L_MET_016617F0AE51761167D8F971D65FF65C_30:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_43b92a37d49a7595f8cc10d45be754ec, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_43b92a37d49a7595f8cc10d45be754ec);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 10, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_31:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "include?"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_32:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 85]
  L_MET_016617F0AE51761167D8F971D65FF65C_33:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_732ba98d632e75b51348a436666fd59c, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_732ba98d632e75b51348a436666fd59c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 11, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_34:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "inject"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_35:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 12]
  L_MET_016617F0AE51761167D8F971D65FF65C_36:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "reduce"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 11]
  L_MET_016617F0AE51761167D8F971D65FF65C_37:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "inject"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_38:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_39:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_40:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 13]
  L_MET_016617F0AE51761167D8F971D65FF65C_41:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "map"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_42:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "collect"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_43:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_44:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_45:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 97]
  L_MET_016617F0AE51761167D8F971D65FF65C_46:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_63c0ee75c95ed465fe8ca962deb6b9d9, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_63c0ee75c95ed465fe8ca962deb6b9d9);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 14, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_47:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "max"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_48:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 105]
  L_MET_016617F0AE51761167D8F971D65FF65C_49:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_bee404f8c801a5e6ffaa460a796fac46, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_bee404f8c801a5e6ffaa460a796fac46);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 15, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_50:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "min"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_51:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 16]
  L_MET_016617F0AE51761167D8F971D65FF65C_52:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "member?"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 10]
  L_MET_016617F0AE51761167D8F971D65FF65C_53:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "include?"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_54:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_55:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_56:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 113]
  L_MET_016617F0AE51761167D8F971D65FF65C_57:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_22517d378bf2ebfdf0380a74d22a57a1, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_22517d378bf2ebfdf0380a74d22a57a1);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 17, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_58:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "partition"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_59:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 121]
  L_MET_016617F0AE51761167D8F971D65FF65C_60:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_adc0b53b287718a57d70a31162d700ea, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_adc0b53b287718a57d70a31162d700ea);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 18, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_61:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "reject"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_62:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 19]
  L_MET_016617F0AE51761167D8F971D65FF65C_63:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "select"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 8]
  L_MET_016617F0AE51761167D8F971D65FF65C_64:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "find_all"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_65:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_66:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_67:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 1, 1]
  L_MET_016617F0AE51761167D8F971D65FF65C_68:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5b6e81c9814928c26fcd30c039b1d23b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_5b6e81c9814928c26fcd30c039b1d23b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 20, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_69:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "__sort_sub__"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_70:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 1, 9]
  L_MET_016617F0AE51761167D8F971D65FF65C_71:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_630e760ee96651bfda5de9cb645faad5, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_630e760ee96651bfda5de9cb645faad5);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 21, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_72:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "sort"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_73:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 22]
  L_MET_016617F0AE51761167D8F971D65FF65C_74:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "to_a"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 5]
  L_MET_016617F0AE51761167D8F971D65FF65C_75:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "entries"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_76:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 7, 2]
  L_MET_016617F0AE51761167D8F971D65FF65C_77:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_016617F0AE51761167D8F971D65FF65C_78:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_9656bbbb2825b9d0b3b0f57aed60679e(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_9656BBBB2825B9D0B3B0F57AED60679E_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_9656BBBB2825B9D0B3B0F57AED60679E_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_LOADSELF", 3, 0, 0]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_2:
  {
      /* A      R(A) := self */
      regs[3] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_3:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_SENDB", 3, 1, 0]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_4:
  {
      int a = 3;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "sort"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 2, 0, 1]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_5:
  {
      int a = 2;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "replace"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 2, 0, 0]
  L_MET_9656BBBB2825B9D0B3B0F57AED60679E_6:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[2];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f2a36f506bfae57ae47d00037ce6d2f0(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (3 < 3) ? 3 : 3, 3);
  }
  else {
    stack_extend(mrb, 3, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 3 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_0:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 1]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_1:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Enumerable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_2:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_3:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 2]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_4:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Comparable"));
      NEXT;
    }

  // ["OP_SEND", 1, 0, 1]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_5:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "include"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_9656bbbb2825b9d0b3b0f57aed60679e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_9656bbbb2825b9d0b3b0f57aed60679e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 3, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "sort!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_9:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_F2A36F506BFAE57AE47D00037CE6D2F0_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_6685640f3ca681c6d4f0909a69851481(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_6685640F3CA681C6D4F0909A69851481_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_6685640F3CA681C6D4F0909A69851481_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_937b71d76575203706ce42106c048234(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (2 < 3) ? 3 : 2, 3);
  }
  else {
    stack_extend(mrb, 2, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 2 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_937B71D76575203706CE42106C048234_0:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_937B71D76575203706CE42106C048234_1:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_f533c93482702a9c609f03a473df608d(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262145;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_F533C93482702A9C609F03A473DF608D_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_F533C93482702A9C609F03A473DF608D_1;
      }
      
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_F533C93482702A9C609F03A473DF608D_1:
  goto L_MET_F533C93482702A9C609F03A473DF608D_6;
  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_2:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_3:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 5, 0, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_4:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "delete_at"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 4, 1, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_5:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_6:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_7:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 5, 1, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_8:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "index"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 5, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_9:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[5];
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 119]
  L_MET_F533C93482702A9C609F03A473DF608D_10:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_F533C93482702A9C609F03A473DF608D_2;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 4, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_11:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_LOADNIL", 6, 0, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_12:
  {
      /* A B    R(A) := nil */
      int a = 6;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_EQ", 5, 2, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_13:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5;
      if (mrb_obj_eq(mrb, regs[a], regs[a+1])) {
  SET_TRUE_VALUE(regs[a]);
      }
      else {
  int a = 5; OP_CMP(==);
      }
      NEXT;
    }

  // ["OP_JMPNOT", 5, 256, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_14:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_F533C93482702A9C609F03A473DF608D_16;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_15:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_JMPNOT", 5, 256, 3]
  L_MET_F533C93482702A9C609F03A473DF608D_16:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_F533C93482702A9C609F03A473DF608D_20;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_17:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 5, 3, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_18:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 1]
  L_MET_F533C93482702A9C609F03A473DF608D_19:
  goto L_MET_F533C93482702A9C609F03A473DF608D_21;
  // ["OP_MOVE", 5, 4, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_20:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_RETURN", 5, 0, 0]
  L_MET_F533C93482702A9C609F03A473DF608D_21:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[5];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_b244c5bb2f6db3b7dabc62a030aad1d2(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (9 < 3) ? 3 : 9, 3);
  }
  else {
    stack_extend(mrb, 9, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 9 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 128, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 16385;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
  
    switch(argc) {
  case 0: goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_1;
  case 1: goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_2;
}

      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_3;
      }
      
    }

  // ["OP_JMP", 0, 256, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_1:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_4;
  // ["OP_JMP", 0, 256, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_2:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_5;
  // ["OP_JMP", 0, 256, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_3:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_6;
  // ["OP_LOADI", 1, 255, 127]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_4:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[1], 0);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_5:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_6:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_GETCONST", 6, 0, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_7:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Integer"));
      NEXT;
    }

  // ["OP_SEND", 5, 0, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_8:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "kind_of?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 5, 256, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_9:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_11;
      }
      NEXT;
    }

  // ["OP_JMP", 0, 256, 4]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_10:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_15;
  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_11:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 6, 0, 3]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_12:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "TypeError"));
      NEXT;
    }

  // ["OP_STRING", 7, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_13:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "expected Integer for 1st argument");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 2, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_14:
  {
      int a = 5;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_15:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 6, 255, 127]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_16:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 0);
      NEXT;
    }

  // ["OP_LT", 5, 4, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_17:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPNOT", 5, 256, 4]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_18:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_23;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_19:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_GETCONST", 6, 0, 5]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_20:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[6] = mrb_vm_const_get(mrb, mrb_intern(mrb, "ArgumentError"));
      NEXT;
    }

  // ["OP_STRING", 7, 0, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_21:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[7] = mrb_str_new_cstr(mrb, "negative array size");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SEND", 5, 2, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_22:
  {
      int a = 5;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "raise"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 5, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_23:
  {
      /* A      R(A) := self */
      regs[5] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 5, 6, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_24:
  {
      int a = 5;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "clear"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_25:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_LOADI", 6, 255, 127]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_26:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[6], 0);
      NEXT;
    }

  // ["OP_GT", 5, 7, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_27:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(>);
      NEXT;
    }

  // ["OP_JMPNOT", 5, 256, 26]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_28:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_55;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 5, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_29:
  {
      /* A B    R(A) := nil */
      int a = 5;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_30:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 1, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_31:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[1];
      NEXT;
    }

  // ["OP_SUBI", 7, 9, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_32:
  {
      /* A B C  R(A) := R(A)-C (Syms[B]=:+)*/
      int a = 7;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x - y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x - (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f -= 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "-"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 8, 5, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_33:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[5];
      NEXT;
    }

  // ["OP_SEND", 6, 8, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_34:
  {
      int a = 6;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADI", 4, 255, 127]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_35:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[4], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 14]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_36:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_51;
  // ["OP_MOVE", 5, 3, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_37:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_JMPNOT", 5, 256, 4]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_38:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[5])) {
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_43;
      }
      NEXT;
    }

  // ["OP_MOVE", 5, 3, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_39:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 6, 4, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_40:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[4];
      NEXT;
    }

  // ["OP_SEND", 5, 10, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_41:
  {
      int a = 5;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMP", 0, 256, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_42:
  goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_44;
  // ["OP_MOVE", 5, 2, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_43:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 6, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_44:
  {
      /* A      R(A) := self */
      regs[6] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 7, 4, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_45:
  {
      /* A B    R(A) := R(B) */
      regs[7] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 8, 5, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_46:
  {
      /* A B    R(A) := R(B) */
      regs[8] = regs[5];
      NEXT;
    }

  // ["OP_SEND", 6, 8, 2]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_47:
  {
      int a = 6;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 5, 4, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_48:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_ADDI", 5, 11, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_49:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 5;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 4, 5, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_50:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[5];
      NEXT;
    }

  // ["OP_MOVE", 5, 4, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_51:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[4];
      NEXT;
    }

  // ["OP_MOVE", 6, 1, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_52:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[1];
      NEXT;
    }

  // ["OP_LT", 5, 4, 1]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_53:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 5; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 5, 255, 110]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_54:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[5])) {
        goto L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_37;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_55:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_B244C5BB2F6DB3B7DABC62A030AAD1D2_56:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_68e56b9082670dc004be74f13cf35dbb(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (7 < 3) ? 3 : 7, 3);
  }
  else {
    stack_extend(mrb, 7, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 7 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 4, 0, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 262144;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_68E56B9082670DC004BE74F13CF35DBB_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_68E56B9082670DC004BE74F13CF35DBB_1;
      }
      
    }

  // ["OP_GETUPVAR", 3, 1, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_1:
  {
      /* A B C  R(A) := uvget(B,C) */

      regs[3] = uvget(mrb, 0, 1);
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_2:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_3:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_4:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_6:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 1, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_7:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 6, 3, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_8:
  {
      /* A B    R(A) := R(B) */
      regs[6] = regs[3];
      NEXT;
    }

  // ["OP_SEND", 4, 2, 2]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_9:
  {
      int a = 4;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]="), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_RETURN", 3, 0, 0]
  L_MET_68E56B9082670DC004BE74F13CF35DBB_10:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[3];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_aeba18d328f8511d36096cba9fa44b29(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_AEBA18D328F8511D36096CBA9FA44B29_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_AEBA18D328F8511D36096CBA9FA44B29_1;
      }
      
    }

  // ["OP_LOADSELF", 2, 0, 0]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_1:
  {
      /* A      R(A) := self */
      regs[2] = regs[0];
      NEXT;
    }

  // ["OP_LAMBDA", 3, 0, 6]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_2:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_68e56b9082670dc004be74f13cf35dbb, (unsigned int)2);
      }
      else {
        p = mrbb_proc_new(mrb, met_68e56b9082670dc004be74f13cf35dbb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 2, 0, 0]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_3:
  {
      int a = 2;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "each_index"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_4:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_AEBA18D328F8511D36096CBA9FA44B29_5:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_561f34c458cb37f73552f0dc2dee3dec(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_561F34C458CB37F73552F0DC2DEE3DEC_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_561F34C458CB37F73552F0DC2DEE3DEC_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 6]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_2:
  goto L_MET_561F34C458CB37F73552F0DC2DEE3DEC_9;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_3:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_MOVE", 4, 2, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_4:
  {
      /* A B    R(A) := R(B) */
      regs[4] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 3, 0, 1]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_5:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_6:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_ADDI", 3, 1, 1]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_7:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_8:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_9:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_10:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 3, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_11:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "length"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LT", 3, 2, 1]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_12:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 3, 255, 117]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_13:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_561F34C458CB37F73552F0DC2DEE3DEC_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_14:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_561F34C458CB37F73552F0DC2DEE3DEC_15:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_3be2ba9656faebfc52a00754919bbbe1(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (6 < 3) ? 3 : 6, 3);
  }
  else {
    stack_extend(mrb, 6, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 6 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_ENTER", 0, 0, 1]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_0:
  {
      /* Ax             arg setup according to flags (24=5:5:1:5:5:1:1) */
      /* number of optional arguments times OP_JMP should follow */
      int ax = 1;
      int m1 = (ax>>18)&0x1f;
      int o  = (ax>>13)&0x1f;
      int r  = (ax>>12)&0x1;
      int m2 = (ax>>7)&0x1f;
      /* unused
      int k  = (ax>>2)&0x1f;
      int kd = (ax>>1)&0x1;
      int b  = (ax>>0)& 0x1;
      */
      int argc = mrb->ci->argc;
      mrb_value *argv = regs+1;
      mrb_value *argv0 = argv;
      int len = m1 + o + r + m2;
      mrb_value *blk = &argv[argc < 0 ? 1 : argc];

      if (argc < 0) {
        struct RArray *ary = mrb_ary_ptr(regs[1]);
        argv = ary->ptr;
        argc = ary->len;
  mrb_gc_protect(mrb, regs[1]);
      }
      if (mrb->ci->proc && MRB_PROC_STRICT_P(mrb->ci->proc)) {
        if (argc >= 0) {
          if (argc < m1 + m2 || (r == 0 && argc > len)) {
      argnum_error(mrb, m1+m2);
      mrbb_raise(mrb, prev_jmp);
          }
        }
      }
      else if (len > 1 && argc == 1 && mrb_array_p(argv[0])) {
        argc = mrb_ary_ptr(argv[0])->len;
        argv = mrb_ary_ptr(argv[0])->ptr;
      }
      mrb->ci->argc = len;
      if (argc < len) {
        regs[len+1] = *blk; /* move block */
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(argc-m2)); /* m1 + o */
        }
        if (m2) {
          memmove(&regs[len-m2+1], &argv[argc-m2], sizeof(mrb_value)*m2); /* m2 */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_capa(mrb, 0);
        }
   goto L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_1;
      }
      else {
        if (argv0 != argv) {
          memmove(&regs[1], argv, sizeof(mrb_value)*(m1+o)); /* m1 + o */
        }
        if (r) {                  /* r */
          regs[m1+o+1] = mrb_ary_new_elts(mrb, argc-m1-o-m2, argv+m1+o);
        }
        if (m2) {
          memmove(&regs[m1+o+r+1], &argv[argc-m2], sizeof(mrb_value)*m2);
        }
        regs[len+1] = *blk; /* move block */
        goto L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_1;
      }
      
    }

  // ["OP_LOADI", 2, 255, 127]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_1:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[2], 0);
      NEXT;
    }

  // ["OP_JMP", 0, 256, 8]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_2:
  goto L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_11;
  // ["OP_MOVE", 3, 1, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_3:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[1];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_4:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_MOVE", 5, 2, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_5:
  {
      /* A B    R(A) := R(B) */
      regs[5] = regs[2];
      NEXT;
    }

  // ["OP_SEND", 4, 1, 1]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_6:
  {
      int a = 4;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "[]"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SEND", 3, 0, 1]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_7:
  {
      int a = 3;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "call"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_8:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_ADDI", 3, 2, 1]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_9:
  {
      /* A B C  R(A) := R(A)+C (Syms[B]=:+)*/
      int a = 3;

      /* need to check if + is overridden */
      switch (mrb_type(regs[a])) {
      case MRB_TT_FIXNUM:
  {
    mrb_int x = regs[a].attr_i;
    mrb_int y = 1;
    mrb_int z = x + y;

    if (((x < 0) ^ (y < 0)) == 0 && (x < 0) != (z < 0)) {
      /* integer overflow */
      SET_FLT_VALUE(regs[a], (mrb_float)x + (mrb_float)y);
      break;
    }
    regs[a].attr_i = z;
  }
        break;
      case MRB_TT_FLOAT:
        regs[a].attr_f += 1;
        break;
      default:
        SET_INT_VALUE(regs[a+1], 1);
        
        regs[a] = mrb_funcall_with_block(mrb, regs[a], mrb_intern(mrb, "+"), 1, &regs[a+1], mrb_nil_value());
      }
      NEXT;
    }

  // ["OP_MOVE", 2, 3, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_10:
  {
      /* A B    R(A) := R(B) */
      regs[2] = regs[3];
      NEXT;
    }

  // ["OP_MOVE", 3, 2, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_11:
  {
      /* A B    R(A) := R(B) */
      regs[3] = regs[2];
      NEXT;
    }

  // ["OP_LOADSELF", 4, 0, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_12:
  {
      /* A      R(A) := self */
      regs[4] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 4, 4, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_13:
  {
      int a = 4;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "length"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LT", 3, 3, 1]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_14:
  {
      /* A B C  R(A) := R(A)<R(A+1) (Syms[B]=:<,C=1)*/
      int a = 3; OP_CMP(<);
      NEXT;
    }

  // ["OP_JMPIF", 3, 255, 115]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_15:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (mrb_test(regs[3])) {
        goto L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_3;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 0, 0, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_16:
  {
      /* A      R(A) := self */
      regs[0] = regs[0];
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_3BE2BA9656FAEBFC52A00754919BBBE1_17:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value met_819d7528635aa15bc0cd5018d0f293ef(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (4 < 3) ? 3 : 4, 3);
  }
  else {
    stack_extend(mrb, 4, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 4 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_0:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 5]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_1:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3be2ba9656faebfc52a00754919bbbe1, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_3be2ba9656faebfc52a00754919bbbe1);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_2:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_3:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 9]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_4:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_561f34c458cb37f73552f0dc2dee3dec, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_561f34c458cb37f73552f0dc2dee3dec);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 1, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_5:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "each_index"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_6:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 13]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_7:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_aeba18d328f8511d36096cba9fa44b29, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_aeba18d328f8511d36096cba9fa44b29);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 2, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_8:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "collect!"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_9:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 3]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_10:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "map!"));
      NEXT;
    }

  // ["OP_LOADSYM", 3, 0, 2]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_11:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[3], mrb_intern(mrb, "collect!"));
      NEXT;
    }

  // ["OP_LOADNIL", 4, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_12:
  {
      /* A B    R(A) := nil */
      int a = 4;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_SEND", 1, 4, 2]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_13:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "alias_method"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_14:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 21]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_15:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b244c5bb2f6db3b7dabc62a030aad1d2, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b244c5bb2f6db3b7dabc62a030aad1d2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 5, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_16:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "initialize"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_17:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 0, 25]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_18:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f533c93482702a9c609f03a473df608d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f533c93482702a9c609f03a473df608d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 6, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_19:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "delete"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADNIL", 0, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_20:
  {
      /* A B    R(A) := nil */
      int a = 0;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_RETURN", 0, 0, 0]
  L_MET_819D7528635AA15BC0CD5018D0F293EF_21:
  {
      {
        mrb_callinfo *ci = mrb->ci;
        int acc, eidx = mrb->ci->eidx;
        mrb_value v = regs[0];

        if (mrb->exc) {
          mrbb_raise(mrb, 0);
        }

        switch (0) {
        case OP_R_RETURN:
          if (proc->env || !MRB_PROC_STRICT_P(proc)) {
            struct REnv *e = top_env(mrb, proc);

            if (e->cioff < 0) {
              localjump_error(mrb, "return");
              mrbb_raise(mrb, prev_jmp);
            }
            mrb->ci = mrb->cibase + e->cioff;
            break;
          }
        case OP_R_NORMAL:
          if (ci == mrb->cibase) {
            localjump_error(mrb, "return");
            mrbb_raise(mrb, prev_jmp);
          }
          break;
        case OP_R_BREAK:
          if (proc->env->cioff < 0) {
            localjump_error(mrb, "break");
            mrbb_raise(mrb, prev_jmp);
          }
          mrb->ci = mrb->cibase + proc->env->cioff + 1;
          break;
        default:
          /* cannot happen */
          break;
        }

        if (acc >= 0) {
          //printf("RETURN2RB?\n");
          //exit(0);
        }
        while (eidx > mrb->ci[-1].eidx) {
          mrbb_ecall(mrb, mrb->ensure[--eidx]);
        }
        mrb->jmp = prev_jmp;
        /*
        if (acc < 0) {
          mrb->jmp = prev_jmp;
          return v;
        }
        */
        // TODO optimize (cipop in funcall)
        // important with OP_RETURN break
        return v;
      }
    }

}
mrb_value rb_main(mrb_state *mrb, mrb_value self) {
  mrb_value *regs = NULL;
  int ai = mrb->arena_idx;
  jmp_buf *prev_jmp = (jmp_buf *)mrb->jmp; // TODO remove
  jmp_buf *prev_jmp_onerr = prev_jmp; // TODO OP_ONERR?
  jmp_buf *prev_jmp_ensure = prev_jmp; // TODO OP_EPUSH
  struct RProc *proc = mrb->ci->proc;
  mrb_callinfo *ci = mrb->ci;

  // I have to set up my own stack
  if (ci->argc < 0) {
    stack_extend(mrb, (5 < 3) ? 3 : 5, 3);
  }
  else {
    stack_extend(mrb, 5, ci->argc+2);
  }

  //mrb->ci->proc = proc;
  mrb->ci->nregs = 5 + 2;
  regs = mrb->stack;
  regs[0] = self;
  // TODO regs[0] = m->env->stack[0]; ? OP_CALL

/*
        mrb->jmp = prev_jmp_ensure; // TODO: what about retry?
        mrbb_ecall(mrb, mrbb_proc_new(mrb, GETARG_Bx(i)));
        longjmp(*(jmp_buf*)mrb->jmp, 1);
*/

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_0:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_1:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 0, 0]
  L_RB_MAIN_2:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Array");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 1]
  L_RB_MAIN_3:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_819d7528635aa15bc0cd5018d0f293ef);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_819d7528635aa15bc0cd5018d0f293ef]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_4:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 1, 0]
  L_RB_MAIN_5:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Enumerable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 8]
  L_RB_MAIN_6:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_937b71d76575203706ce42106c048234);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_937b71d76575203706ce42106c048234]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_7:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 2, 0]
  L_RB_MAIN_8:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Comparable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 9]
  L_RB_MAIN_9:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_6685640f3ca681c6d4f0909a69851481);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_6685640f3ca681c6d4f0909a69851481]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_10:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_11:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 0, 0]
  L_RB_MAIN_12:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Array");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 10]
  L_RB_MAIN_13:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_f2a36f506bfae57ae47d00037ce6d2f0);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_f2a36f506bfae57ae47d00037ce6d2f0]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_14:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 1, 0]
  L_RB_MAIN_15:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Enumerable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 12]
  L_RB_MAIN_16:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_016617f0ae51761167d8f971d65ff65c);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_016617f0ae51761167d8f971d65ff65c]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_17:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_18:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 3, 0]
  L_RB_MAIN_19:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Module");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 48]
  L_RB_MAIN_20:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_669e9055cb511bf8fa47a11463cd4434);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_669e9055cb511bf8fa47a11463cd4434]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_21:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 2, 0]
  L_RB_MAIN_22:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Comparable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 57]
  L_RB_MAIN_23:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_495c37ccc70eea4e380b35b6e353e63a);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_495c37ccc70eea4e380b35b6e353e63a]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_24:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_25:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 4, 0]
  L_RB_MAIN_26:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Exception");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 64]
  L_RB_MAIN_27:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_dd6d28c90d02b371f1856e043f842f53);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_dd6d28c90d02b371f1856e043f842f53]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_28:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_29:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 6, 0]
  L_RB_MAIN_30:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "ArgumentError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 66]
  L_RB_MAIN_31:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_df7c0eb9dcf5fa39497e6858264aac42);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_df7c0eb9dcf5fa39497e6858264aac42]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_32:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_33:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 7, 0]
  L_RB_MAIN_34:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "LocalJumpError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 67]
  L_RB_MAIN_35:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_5ef33952ba6f987404d90f6a8e7102bf);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_5ef33952ba6f987404d90f6a8e7102bf]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_36:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_37:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 8, 0]
  L_RB_MAIN_38:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "RangeError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 68]
  L_RB_MAIN_39:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_513d2a2f35b52951a1ac2aa83b7a824c);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_513d2a2f35b52951a1ac2aa83b7a824c]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_40:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 8]
  L_RB_MAIN_41:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "RangeError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 9, 0]
  L_RB_MAIN_42:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "FloatDomainError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 69]
  L_RB_MAIN_43:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_d70d685178cb64e87cd42b8623f38eb4);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_d70d685178cb64e87cd42b8623f38eb4]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_44:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_45:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 10, 0]
  L_RB_MAIN_46:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "RegexpError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 70]
  L_RB_MAIN_47:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_de16e07ca4abd25783aaadf78fcf769d);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_de16e07ca4abd25783aaadf78fcf769d]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_48:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_49:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 11, 0]
  L_RB_MAIN_50:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "TypeError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 71]
  L_RB_MAIN_51:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_4fafa3a7fe04ebf88fcb6be967e674d8);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_4fafa3a7fe04ebf88fcb6be967e674d8]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_52:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_53:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 12, 0]
  L_RB_MAIN_54:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "NameError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 72]
  L_RB_MAIN_55:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_225cae63531646b6585dcb10e11f1ce9);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_225cae63531646b6585dcb10e11f1ce9]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_56:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 12]
  L_RB_MAIN_57:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "NameError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 13, 0]
  L_RB_MAIN_58:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "NoMethodError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 73]
  L_RB_MAIN_59:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_da5ce7e35ecc5efd33e0ed6116e5805c);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_da5ce7e35ecc5efd33e0ed6116e5805c]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_60:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 5]
  L_RB_MAIN_61:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "StandardError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 14, 0]
  L_RB_MAIN_62:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "IndexError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 74]
  L_RB_MAIN_63:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_36daf3be6f2106dc2720ed4049fe39ac);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_36daf3be6f2106dc2720ed4049fe39ac]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_64:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 14]
  L_RB_MAIN_65:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "IndexError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 15, 0]
  L_RB_MAIN_66:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "KeyError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 75]
  L_RB_MAIN_67:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_05db3b6057f5e307543f5a8cd6ad2089);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_05db3b6057f5e307543f5a8cd6ad2089]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_68:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_GETCONST", 2, 0, 16]
  L_RB_MAIN_69:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[2] = mrb_vm_const_get(mrb, mrb_intern(mrb, "ScriptError"));
      NEXT;
    }

  // ["OP_CLASS", 1, 17, 0]
  L_RB_MAIN_70:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "NotImplementedError");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 76]
  L_RB_MAIN_71:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_b2efba03e85432f7f3057cb06a847acb);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_b2efba03e85432f7f3057cb06a847acb]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_72:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_73:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 18, 0]
  L_RB_MAIN_74:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Hash");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 77]
  L_RB_MAIN_75:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_21a453610861811ef8be38c740f232a6);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_21a453610861811ef8be38c740f232a6]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_76:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 1, 0]
  L_RB_MAIN_77:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Enumerable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 100]
  L_RB_MAIN_78:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_d32b189f6d0c9da345245f2bc7305b1b);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_d32b189f6d0c9da345245f2bc7305b1b]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_79:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_80:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 18, 0]
  L_RB_MAIN_81:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Hash");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 101]
  L_RB_MAIN_82:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_4b50dff2bf09778333229dc93623fe20);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_4b50dff2bf09778333229dc93623fe20]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_83:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 19, 0]
  L_RB_MAIN_84:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Kernel");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 102]
  L_RB_MAIN_85:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_41556fda4224ba58910dbd8d37c2c174);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_41556fda4224ba58910dbd8d37c2c174]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_86:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_87:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 20, 0]
  L_RB_MAIN_88:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Integer");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 107]
  L_RB_MAIN_89:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_c09e2f97a0ceaf65200b58cdc9ef38f5);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_c09e2f97a0ceaf65200b58cdc9ef38f5]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_90:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 2, 0]
  L_RB_MAIN_91:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Comparable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 112]
  L_RB_MAIN_92:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_d7cd309660f17ad68edc8d5f2e23c79a);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_d7cd309660f17ad68edc8d5f2e23c79a]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_93:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_94:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 21, 0]
  L_RB_MAIN_95:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Numeric");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 113]
  L_RB_MAIN_96:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_ab4246b29884a51a89ba8be8a5382f41);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_ab4246b29884a51a89ba8be8a5382f41]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_97:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 19, 0]
  L_RB_MAIN_98:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Kernel");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 114]
  L_RB_MAIN_99:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_aabcef40440421089b94608388c7200a);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_aabcef40440421089b94608388c7200a]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_100:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_101:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 22, 0]
  L_RB_MAIN_102:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Range");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 125]
  L_RB_MAIN_103:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_4727db1f3bad8f9c2851d61e88442727);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_4727db1f3bad8f9c2851d61e88442727]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_104:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 1, 0]
  L_RB_MAIN_105:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Enumerable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 0, 127]
  L_RB_MAIN_106:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_c38d302a7f3f4d0b7cb2b60b1a27c8ae);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_c38d302a7f3f4d0b7cb2b60b1a27c8ae]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_107:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_108:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 22, 0]
  L_RB_MAIN_109:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Range");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 1, 0]
  L_RB_MAIN_110:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_be61fdad296d276710c528c5f12d9067);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_be61fdad296d276710c528c5f12d9067]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_111:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_112:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 23, 0]
  L_RB_MAIN_113:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "String");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 1, 1]
  L_RB_MAIN_114:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_c553f446c939911bcdb59bff0006d798);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_c553f446c939911bcdb59bff0006d798]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_115:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_MODULE", 1, 2, 0]
  L_RB_MAIN_116:
  {
      /* A B            R(A) := newmodule(R(A),Sym(B)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base;
      mrb_sym id = mrb_intern(mrb, "Comparable");

      base = regs[a];
      if (mrb_nil_p(base)) {
  base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_module(mrb, base, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 1, 11]
  L_RB_MAIN_117:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_3dfe782fc0a622f1fd2ca633d5e6e445);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_3dfe782fc0a622f1fd2ca633d5e6e445]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_118:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_119:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 23, 0]
  L_RB_MAIN_120:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "String");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 1, 12]
  L_RB_MAIN_121:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_b238a0163abaec5335665cfa1485ee9f);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_b238a0163abaec5335665cfa1485ee9f]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 24]
  L_RB_MAIN_122:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 26]
  L_RB_MAIN_123:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "Struct"));
      NEXT;
    }

  // ["OP_SEND", 1, 25, 1]
  L_RB_MAIN_124:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 4]
  L_RB_MAIN_125:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_RB_MAIN_130;
      }
      NEXT;
    }

  // ["OP_LOADNIL", 1, 0, 0]
  L_RB_MAIN_126:
  {
      /* A B    R(A) := nil */
      int a = 1;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_LOADNIL", 2, 0, 0]
  L_RB_MAIN_127:
  {
      /* A B    R(A) := nil */
      int a = 2;

      SET_NIL_VALUE(regs[a]);
      NEXT;
    }

  // ["OP_CLASS", 1, 26, 0]
  L_RB_MAIN_128:
  {
      /* A B    R(A) := newclass(R(A),Sym(B),R(A+1)) */
      struct RClass *c = 0;
      int a = 1;
      mrb_value base, super;
      mrb_sym id = mrb_intern(mrb, "Struct");

      base = regs[a];
      super = regs[a+1];
      if (mrb_nil_p(base)) {
        base = mrb_obj_value(mrb->ci->target_class);
      }
      c = mrb_vm_define_class(mrb, base, super, id);
      regs[a] = mrb_obj_value(c);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_EXEC", 1, 1, 13]
  L_RB_MAIN_129:
  {
      /* A Bx   R(A) := blockexec(R(A),SEQ[Bx]) */
      int a = 1;
      mrb_callinfo *ci;
      mrb_value recv = regs[a];
      struct RProc *p;

      /* prepare stack */
      ci = cipush(mrb);
      //ci->pc = pc + 1;
      ci->acc = a;
      ci->mid = 0;
      ci->stackidx = mrb->stack - mrb->stbase;
      ci->argc = 0;
      ci->target_class = mrb_class_ptr(recv); // TODO: check if we might need mrb_class() instead

      /* prepare stack */
      mrb->stack += a;

      p = mrbb_proc_new(mrb, met_349e3e5266f4969995a6f148801aa20b);
      // p = mrb_proc_new(mrb, mrb->irep[irep->idx+met_349e3e5266f4969995a6f148801aa20b]);
      p->target_class = ci->target_class;
      ci->proc = p;

      // if (MRB_PROC_CFUNC_P(p)) {
      // else part removed since it is always CFUNC

      mrb->stack[0] = p->body.func(mrb, recv);
      mrb->arena_idx = ai;
      if (mrb->exc) mrbb_raise(mrb, prev_jmp);
      /* pop stackpos */
      regs = mrb->stack = mrb->stbase + mrb->ci->stackidx;
      cipop(mrb);
      NEXT;
    }

  // ["OP_LOADI", 1, 255, 127]
  L_RB_MAIN_130:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[1], 0);
      NEXT;
    }

  // ["OP_SETGLOBAL", 1, 0, 27]
  L_RB_MAIN_131:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$ok_test"), regs[1]);
      NEXT;
    }

  // ["OP_LOADI", 1, 255, 127]
  L_RB_MAIN_132:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[1], 0);
      NEXT;
    }

  // ["OP_SETGLOBAL", 1, 0, 28]
  L_RB_MAIN_133:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$ko_test"), regs[1]);
      NEXT;
    }

  // ["OP_LOADI", 1, 255, 127]
  L_RB_MAIN_134:
  {
      /* A Bx   R(A) := sBx */
      SET_INT_VALUE(regs[1], 0);
      NEXT;
    }

  // ["OP_SETGLOBAL", 1, 0, 29]
  L_RB_MAIN_135:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$kill_test"), regs[1]);
      NEXT;
    }

  // ["OP_ARRAY", 1, 1, 0]
  L_RB_MAIN_136:
  {
      /* A B C          R(A) := ary_new(R(B),R(B+1)..R(B+C)) */
      regs[1] = mrb_ary_new_from_values(mrb, 0, &regs[1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SETGLOBAL", 1, 0, 30]
  L_RB_MAIN_137:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$asserts"), regs[1]);
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 24]
  L_RB_MAIN_138:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 31]
  L_RB_MAIN_139:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 25, 1]
  L_RB_MAIN_140:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 256, 3]
  L_RB_MAIN_141:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_RB_MAIN_145;
      }
      NEXT;
    }

  // ["OP_GETCONST", 1, 0, 31]
  L_RB_MAIN_142:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 32, 0]
  L_RB_MAIN_143:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "now"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_SETGLOBAL", 1, 0, 33]
  L_RB_MAIN_144:
  {
      /* setglobal(Sym(b), R(A)) */
      mrb_gv_set(mrb, mrb_intern(mrb, "$test_start"), regs[1]);
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_RB_MAIN_145:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 4, 81]
  L_RB_MAIN_146:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_c16e0e25b79c980c135083c5add3d174, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_c16e0e25b79c980c135083c5add3d174);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 34, 0]
  L_RB_MAIN_147:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "print_assertion_string"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_RB_MAIN_148:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 4, 85]
  L_RB_MAIN_149:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_ea1a28002a327accdd5661ce755da16a, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_ea1a28002a327accdd5661ce755da16a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 35, 0]
  L_RB_MAIN_150:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "assert"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_RB_MAIN_151:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 4, 89]
  L_RB_MAIN_152:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_c2a47b6fbb506f8ea8ba37dbf6137507, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_c2a47b6fbb506f8ea8ba37dbf6137507);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 36, 0]
  L_RB_MAIN_153:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "report"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_TCLASS", 1, 0, 0]
  L_RB_MAIN_154:
  {
      /* A B    R(A) := target_class */
      if (!mrb->ci->target_class) {
        static const char msg[] = "no target class or module";
        mrb_value exc = mrb_exc_new(mrb, E_TYPE_ERROR, msg, sizeof(msg) - 1);
        mrb->exc = (struct RObject*)mrb_object(exc);
        mrbb_raise(mrb, prev_jmp);
      }
      regs[1] = mrb_obj_value(mrb->ci->target_class);
      NEXT;
    }

  // ["OP_LAMBDA", 2, 4, 97]
  L_RB_MAIN_155:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 1;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_3b0156252f97092a27796ee279bb3251, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_3b0156252f97092a27796ee279bb3251);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[2] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_METHOD", 1, 37, 0]
  L_RB_MAIN_156:
  {
      /* A B            R(A).newmethod(Sym(B),R(A+1)) */
      int a = 1;
      struct RClass *c = mrb_class_ptr(regs[a]);

      mrb_define_method_vm(mrb, c, mrb_intern(mrb, "check_float"), regs[a+1]);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_157:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 0]
  L_RB_MAIN_158:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "super");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 1]
  L_RB_MAIN_159:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "11.3.4");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 4, 102]
  L_RB_MAIN_160:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5a17bba0f19b4dc0b1d9b3c1dddc44f5, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_5a17bba0f19b4dc0b1d9b3c1dddc44f5);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_161:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_162:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 2]
  L_RB_MAIN_163:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "yield");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 3]
  L_RB_MAIN_164:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "11.3.5");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 2]
  L_RB_MAIN_165:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4e31f578537489f74270e3ba8e855c40, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_4e31f578537489f74270e3ba8e855c40);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_166:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_167:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 4]
  L_RB_MAIN_168:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Abbreviated variable assignment");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 5]
  L_RB_MAIN_169:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "11.4.2.3.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 6]
  L_RB_MAIN_170:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_7cf4f6b9817a7fe01a139216dbfcc8a8, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_7cf4f6b9817a7fe01a139216dbfcc8a8);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_171:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_172:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 6]
  L_RB_MAIN_173:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Nested const reference");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 3, 5, 10]
  L_RB_MAIN_174:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1833288fb63445a1d38c312cafc90a9f, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1833288fb63445a1d38c312cafc90a9f);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 1]
  L_RB_MAIN_175:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_176:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 7]
  L_RB_MAIN_177:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Abbreviated variable assignment as returns");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 3, 5, 26]
  L_RB_MAIN_178:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_41b2a821128decc5b6b1fea594c4569b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_41b2a821128decc5b6b1fea594c4569b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 1]
  L_RB_MAIN_179:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_GETCONST", 1, 0, 24]
  L_RB_MAIN_180:
  {
      /* A B    R(A) := constget(Sym(B)) */
      regs[1] = mrb_vm_const_get(mrb, mrb_intern(mrb, "Object"));
      NEXT;
    }

  // ["OP_LOADSYM", 2, 0, 31]
  L_RB_MAIN_181:
  {
      /* A B    R(A) := Sym(B) */
      SET_SYM_VALUE(regs[2], mrb_intern(mrb, "Time"));
      NEXT;
    }

  // ["OP_SEND", 1, 25, 1]
  L_RB_MAIN_182:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "const_defined?"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_JMPNOT", 1, 257, 70]
  L_RB_MAIN_183:
  {
      /* A sBx  if R(A) pc+=sBx */
      if (!mrb_test(regs[1])) {
        goto L_RB_MAIN_382;
      }
      NEXT;
    }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_184:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 8]
  L_RB_MAIN_185:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.new");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 9]
  L_RB_MAIN_186:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.3.3.3");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 42]
  L_RB_MAIN_187:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_36e70ff1ab501133a0f69794c36c6a5c, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_36e70ff1ab501133a0f69794c36c6a5c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_188:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_189:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 10]
  L_RB_MAIN_190:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 11]
  L_RB_MAIN_191:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 46]
  L_RB_MAIN_192:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_49370cf2a0cd669b15151c7f516ad691, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_49370cf2a0cd669b15151c7f516ad691);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_193:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_194:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 12]
  L_RB_MAIN_195:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time superclass");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 13]
  L_RB_MAIN_196:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 50]
  L_RB_MAIN_197:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_727b0b666b98e01e29c9b6a056258de7, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_727b0b666b98e01e29c9b6a056258de7);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_198:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_199:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 14]
  L_RB_MAIN_200:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.at");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 15]
  L_RB_MAIN_201:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.1");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 54]
  L_RB_MAIN_202:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_0ccad3fdbf6652dcc015863dbe7902b6, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_0ccad3fdbf6652dcc015863dbe7902b6);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_203:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_204:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 16]
  L_RB_MAIN_205:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.gm");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 17]
  L_RB_MAIN_206:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 58]
  L_RB_MAIN_207:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b71aa05047bf88236216cb0e910b585e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b71aa05047bf88236216cb0e910b585e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_208:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_209:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 18]
  L_RB_MAIN_210:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.local");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 19]
  L_RB_MAIN_211:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.3");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 62]
  L_RB_MAIN_212:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_c127d8da80f95dc022637de0d6710e84, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_c127d8da80f95dc022637de0d6710e84);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_213:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_214:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 20]
  L_RB_MAIN_215:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.mktime");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 21]
  L_RB_MAIN_216:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.4");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 66]
  L_RB_MAIN_217:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2e5441658db21184aeacc067abba8e6a, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_2e5441658db21184aeacc067abba8e6a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_218:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_219:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 22]
  L_RB_MAIN_220:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.now");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 23]
  L_RB_MAIN_221:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.5");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 70]
  L_RB_MAIN_222:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_21049a88277aef1532ab0ac2c1aadf8b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_21049a88277aef1532ab0ac2c1aadf8b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_223:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_224:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 24]
  L_RB_MAIN_225:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time.utc");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 25]
  L_RB_MAIN_226:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.6.6");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 74]
  L_RB_MAIN_227:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a57c0c16fce3e207b68d34b7c33f31a5, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a57c0c16fce3e207b68d34b7c33f31a5);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_228:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_229:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 26]
  L_RB_MAIN_230:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#+");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 27]
  L_RB_MAIN_231:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.1");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 78]
  L_RB_MAIN_232:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_98ff349bd7437e51f2bd0442584526d1, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_98ff349bd7437e51f2bd0442584526d1);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_233:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_234:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 28]
  L_RB_MAIN_235:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#-");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 29]
  L_RB_MAIN_236:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 82]
  L_RB_MAIN_237:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_99de27a33cec4915f69bfb362e78fca2, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_99de27a33cec4915f69bfb362e78fca2);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_238:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_239:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 30]
  L_RB_MAIN_240:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#<=>");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 31]
  L_RB_MAIN_241:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.3");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 86]
  L_RB_MAIN_242:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_10cb881b642cb7e34e6804e47da2f040, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_10cb881b642cb7e34e6804e47da2f040);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_243:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_244:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 32]
  L_RB_MAIN_245:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#asctime");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 33]
  L_RB_MAIN_246:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.4");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 90]
  L_RB_MAIN_247:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4027823873624581c18f80db54cb17fb, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_4027823873624581c18f80db54cb17fb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_248:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_249:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 34]
  L_RB_MAIN_250:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#ctime");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 35]
  L_RB_MAIN_251:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.5");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 94]
  L_RB_MAIN_252:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_06c04114c9d0e2e0bf05c02b90834982, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_06c04114c9d0e2e0bf05c02b90834982);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_253:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_254:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 36]
  L_RB_MAIN_255:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#day");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 37]
  L_RB_MAIN_256:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.6");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 98]
  L_RB_MAIN_257:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_cd932e2b13ebb04c5fe4ec4dc043171a, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_cd932e2b13ebb04c5fe4ec4dc043171a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_258:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_259:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 38]
  L_RB_MAIN_260:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#dst?");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 39]
  L_RB_MAIN_261:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.7");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 102]
  L_RB_MAIN_262:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1754bc7343bbfebdd9a29473dcbad29e, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1754bc7343bbfebdd9a29473dcbad29e);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_263:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_264:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 40]
  L_RB_MAIN_265:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#getgm");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 41]
  L_RB_MAIN_266:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.8");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 106]
  L_RB_MAIN_267:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5075298b7009c845df2df0ee7891b57d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_5075298b7009c845df2df0ee7891b57d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_268:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_269:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 42]
  L_RB_MAIN_270:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#getlocal");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 43]
  L_RB_MAIN_271:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.9");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 110]
  L_RB_MAIN_272:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a1cdf505cce0eb2de985160d19d778cd, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a1cdf505cce0eb2de985160d19d778cd);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_273:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_274:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 44]
  L_RB_MAIN_275:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#getutc");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 45]
  L_RB_MAIN_276:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.10");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 114]
  L_RB_MAIN_277:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_d531b90f1d4da92b209ffa95815deb81, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_d531b90f1d4da92b209ffa95815deb81);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_278:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_279:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 46]
  L_RB_MAIN_280:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#gmt?");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 47]
  L_RB_MAIN_281:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.11");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 118]
  L_RB_MAIN_282:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_f20ee96e7bb60113f90b99ddd4fb5b80, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_f20ee96e7bb60113f90b99ddd4fb5b80);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_283:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_284:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 48]
  L_RB_MAIN_285:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#gmtime");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 49]
  L_RB_MAIN_286:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.13");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 122]
  L_RB_MAIN_287:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a0b81409bb56c85a891f2eadc8379f67, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a0b81409bb56c85a891f2eadc8379f67);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_288:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_289:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 50]
  L_RB_MAIN_290:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#hour");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 51]
  L_RB_MAIN_291:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.15");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 5, 126]
  L_RB_MAIN_292:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4b7662e4e7ded7b9f2b1f5309b1ab122, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_4b7662e4e7ded7b9f2b1f5309b1ab122);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_293:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_294:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 52]
  L_RB_MAIN_295:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#initialize_copy");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 53]
  L_RB_MAIN_296:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.17");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 2]
  L_RB_MAIN_297:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_14d2dcdd46be6e8e765409abbd1b8182, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_14d2dcdd46be6e8e765409abbd1b8182);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_298:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_299:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 54]
  L_RB_MAIN_300:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#localtime");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 55]
  L_RB_MAIN_301:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.18");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 6]
  L_RB_MAIN_302:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_45be0eeb4dfd7e0b9c0564e0dcf3a70d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_45be0eeb4dfd7e0b9c0564e0dcf3a70d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_303:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_304:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 56]
  L_RB_MAIN_305:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#mday");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 57]
  L_RB_MAIN_306:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.19");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 10]
  L_RB_MAIN_307:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1ea86c0b3ac7574a85fc007b9c427f88, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1ea86c0b3ac7574a85fc007b9c427f88);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_308:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_309:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 58]
  L_RB_MAIN_310:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#min");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 59]
  L_RB_MAIN_311:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.20");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 14]
  L_RB_MAIN_312:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_898d3518eba48c882a877ef6ef58a996, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_898d3518eba48c882a877ef6ef58a996);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_313:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_314:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 60]
  L_RB_MAIN_315:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#mon");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 61]
  L_RB_MAIN_316:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.21");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 18]
  L_RB_MAIN_317:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_19cd0317af2ad9a4b74f1078797fe697, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_19cd0317af2ad9a4b74f1078797fe697);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_318:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_319:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 62]
  L_RB_MAIN_320:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#month");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 63]
  L_RB_MAIN_321:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.22");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 22]
  L_RB_MAIN_322:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_152b0db8ffc7a9fb7ad74d3c41556327, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_152b0db8ffc7a9fb7ad74d3c41556327);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_323:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_324:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 64]
  L_RB_MAIN_325:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Times#sec");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 65]
  L_RB_MAIN_326:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.23");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 26]
  L_RB_MAIN_327:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_4638d935dc7d7143fae74acaedf7cc91, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_4638d935dc7d7143fae74acaedf7cc91);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_328:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_329:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 66]
  L_RB_MAIN_330:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#to_f");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 67]
  L_RB_MAIN_331:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.24");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 30]
  L_RB_MAIN_332:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b52b414076aeffa382eeaaf715ea5576, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b52b414076aeffa382eeaaf715ea5576);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_333:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_334:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 68]
  L_RB_MAIN_335:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#to_i");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 69]
  L_RB_MAIN_336:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.25");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 34]
  L_RB_MAIN_337:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_bd0fc7d4b2c70a70b9871b82cb497eba, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_bd0fc7d4b2c70a70b9871b82cb497eba);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_338:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_339:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 70]
  L_RB_MAIN_340:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#usec");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 71]
  L_RB_MAIN_341:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.26");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 38]
  L_RB_MAIN_342:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_dd7502dee22d53d5fae35d9abb703217, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_dd7502dee22d53d5fae35d9abb703217);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_343:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_344:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 72]
  L_RB_MAIN_345:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#utc");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 73]
  L_RB_MAIN_346:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.27");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 42]
  L_RB_MAIN_347:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_1e1ffd2730c0e28b7ed1151e7bdcedee, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_1e1ffd2730c0e28b7ed1151e7bdcedee);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_348:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_349:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 74]
  L_RB_MAIN_350:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#utc?");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 75]
  L_RB_MAIN_351:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.28");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 46]
  L_RB_MAIN_352:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_efd73ab93afbc29b8117d0f5eae3e011, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_efd73ab93afbc29b8117d0f5eae3e011);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_353:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_354:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 76]
  L_RB_MAIN_355:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#wday");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 77]
  L_RB_MAIN_356:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.30");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 50]
  L_RB_MAIN_357:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_032ccf47ff65db036fbbf8715f468e67, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_032ccf47ff65db036fbbf8715f468e67);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_358:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_359:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 78]
  L_RB_MAIN_360:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#yday");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 79]
  L_RB_MAIN_361:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.31");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 54]
  L_RB_MAIN_362:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_8cdeed87ce61851c60874c98fc2ae55c, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_8cdeed87ce61851c60874c98fc2ae55c);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_363:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_364:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 80]
  L_RB_MAIN_365:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#year");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 81]
  L_RB_MAIN_366:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.32");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 58]
  L_RB_MAIN_367:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b657fc6460d0960adbe8107d0d33980a, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b657fc6460d0960adbe8107d0d33980a);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_368:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_369:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 82]
  L_RB_MAIN_370:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#zone");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 83]
  L_RB_MAIN_371:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.19.7.33");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 62]
  L_RB_MAIN_372:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_a88747527a10e6148f1dee65b545da4b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_a88747527a10e6148f1dee65b545da4b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_373:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_374:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 84]
  L_RB_MAIN_375:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#to_s");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 3, 6, 66]
  L_RB_MAIN_376:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_10a336857edd72daae9bb134f28e571b, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_10a336857edd72daae9bb134f28e571b);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 1]
  L_RB_MAIN_377:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_378:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 85]
  L_RB_MAIN_379:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "Time#inspect");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 3, 6, 70]
  L_RB_MAIN_380:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b79e959d54168569fb5b023e300e2341, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b79e959d54168569fb5b023e300e2341);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[3] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 1]
  L_RB_MAIN_381:
  {
      int a = 1;
      int n = 1;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_382:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 86]
  L_RB_MAIN_383:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 87]
  L_RB_MAIN_384:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 74]
  L_RB_MAIN_385:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_5f1cbed8106e4bda94be896a69621890, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_5f1cbed8106e4bda94be896a69621890);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_386:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_387:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 88]
  L_RB_MAIN_388:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass superclass");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 89]
  L_RB_MAIN_389:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 78]
  L_RB_MAIN_390:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b3acd40bf2d93567c0ae038237275750, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b3acd40bf2d93567c0ae038237275750);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_391:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_392:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 90]
  L_RB_MAIN_393:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass true");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 91]
  L_RB_MAIN_394:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.1");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 82]
  L_RB_MAIN_395:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_57dd23c795111a9eca73ab04f45e4b59, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_57dd23c795111a9eca73ab04f45e4b59);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_396:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_397:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 92]
  L_RB_MAIN_398:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass#&");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 93]
  L_RB_MAIN_399:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.3.1");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 86]
  L_RB_MAIN_400:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_9562233351605954161511b536e74f3d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_9562233351605954161511b536e74f3d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_401:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_402:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 94]
  L_RB_MAIN_403:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass#^");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 95]
  L_RB_MAIN_404:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.3.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 90]
  L_RB_MAIN_405:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_25abf1625d3a6304f62c8bea86ea70f3, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_25abf1625d3a6304f62c8bea86ea70f3);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_406:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_407:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 96]
  L_RB_MAIN_408:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass#to_s");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 97]
  L_RB_MAIN_409:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.3.3");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 94]
  L_RB_MAIN_410:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_b50016d86bf1b55837f26841d8b62feb, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_b50016d86bf1b55837f26841d8b62feb);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_411:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_412:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 98]
  L_RB_MAIN_413:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TrueClass#|");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 99]
  L_RB_MAIN_414:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.5.3.4");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 98]
  L_RB_MAIN_415:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_536177b75d41c9ae94c669a75074b60d, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_536177b75d41c9ae94c669a75074b60d);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_416:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_417:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 100]
  L_RB_MAIN_418:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TypeError");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 101]
  L_RB_MAIN_419:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.29");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 102]
  L_RB_MAIN_420:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_2b7755a6968750d16badd71878050b63, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_2b7755a6968750d16badd71878050b63);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_421:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_422:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_STRING", 2, 0, 102]
  L_RB_MAIN_423:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[2] = mrb_str_new_cstr(mrb, "TypeError superclass");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_STRING", 3, 0, 103]
  L_RB_MAIN_424:
  {
      /* A Bx           R(A) := str_new(Lit(Bx)) */
      regs[3] = mrb_str_new_cstr(mrb, "15.2.29.2");
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_LAMBDA", 4, 6, 106]
  L_RB_MAIN_425:
  {
      /* A b c  R(A) := lambda(SEQ[b],c) (b:c = 14:2) */
      struct RProc *p;
      int c = 2;

      if (c & OP_L_CAPTURE) {
        p = mrbb_closure_new(mrb, met_eebe105d879ab921e0636da403fe1ffd, (unsigned int)1);
      }
      else {
        p = mrbb_proc_new(mrb, met_eebe105d879ab921e0636da403fe1ffd);
      }
      p->target_class = (mrb->ci) ? mrb->ci->target_class : 0;
      if (c & OP_L_STRICT) p->flags |= MRB_PROC_STRICT;
      regs[4] = mrb_obj_value(p);
      mrb->arena_idx = ai;
      NEXT;
    }

  // ["OP_SENDB", 1, 35, 2]
  L_RB_MAIN_426:
  {
      int a = 1;
      int n = 2;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "assert"), n, &regs[a+1], regs[a+n+1]);
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_LOADSELF", 1, 0, 0]
  L_RB_MAIN_427:
  {
      /* A      R(A) := self */
      regs[1] = regs[0];
      NEXT;
    }

  // ["OP_SEND", 1, 36, 0]
  L_RB_MAIN_428:
  {
      int a = 1;
      int n = 0;
      mrb_callinfo *prev_ci = mrb->ci;

      mrb_funcall_fast(mrb, regs[a], mrb_intern(mrb, "report"), n, &regs[a+1], mrb_nil_value());
      mrb->arena_idx = ai; // TODO probably can remove
      if (mrb->ci != prev_ci) { // special OP_RETURN (e.g. break)
        cipush(mrb);
        return regs[a];
      }
      NEXT;
  }

  // ["OP_STOP", 0, 0, 0]
  L_RB_MAIN_429:
  {
      /*        stop VM */
/*    L_STOP:
      {
  int n = mrb->ci->eidx;

  while (n--) {
    ecall(mrb, n);
  }
      }
      mrb->jmp = prev_jmp;
      if (mrb->exc) {
  return mrb_obj_value(mrb->exc);
      }
      return regs[irep->nlocals];*/
    }

}
